<!--
  ~ Date:2021/12/16 21:03 07
  ~ Name:1、拓展运算符.html
  ~ Path:Web代码/src/com/charlatan/self_study/me/JavaScript/JsBase/拓展运算符
  ~ ProjectName:WWW
  ~ Author:charlatan
  ~
  ~  Il n'ya qu'un héroïsme au monde : c'est de voir le monde tel qu'il est et de l'aimer.
  -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>拓展运算符</title>

</head>
<body>
<pre>
	因为解构赋值要求等号右边的是一个对象，所以如果等号右边是null或undefined，会直接报错

	Rest 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么 Rest 解构赋值拷贝的是这个值的引用，而不是这个值的副本。
	Rest 解构赋值不会拷贝继承自原型对象的属性

	Rest 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。
</pre>
</body>
<script>
	//解构赋值

	let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }
	console.log(x, y, z)

	// let { x, y, ...z } = null; //  运行时错误
	// let { x, y, ...z } = undefined; //  运行时错误
	// Rest 解构赋值必须是最后一个参数，否则会报错。
	// let { ...x, y, z } = obj; //  句法错误
	// let { x, ...y, ...z } = obj; //  句法错误

	//Rest 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么 Rest 解构赋值拷贝的是这个值的引用，而不是这个值的副本。
	let obj = { a: { b: 1 } }
	let { ...num1 } = obj
	obj.a.b = 2000
	console.log(num1.a.b)

	/*
	 * 原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。
	 * */

	function baseFunction ({ a, b }) {
		// ...
	}

	function wrapperFunction ({ x, y, ...restConfig }) {
		//  使用 x 和 y 参数进行操作
		//  其余参数传给原始函数
		return baseFunction(restConfig)
	}
</script>
</html>
