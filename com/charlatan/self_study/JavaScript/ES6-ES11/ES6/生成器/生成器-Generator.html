<!--
  ~ Date:2022/1/6 13:50 16
  ~ Name:生成器-Generator.html
  ~ Path:Web代码/src/com/charlatan/self_study/JavaScript/ES6-ES11/ES6
  ~ ProjectName:WWW
  ~ Author:charlatan
  ~
  ~  Il n'ya qu'un héroïsme au monde : c'est de voir le monde tel qu'il est et de l'aimer.
  -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>生成器</title>

</head>
<body>
<pre>
	生成器：
		使用 function* 语法和一个或多个 yield 表达式以创建一个函数即为生成器，当然它的返回值就是一个迭代器即生成器

	整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明
</pre>
</body>
<script>
	function* func(agrs) {
		return yield agrs
	}

	let gen = func("测试")
	console.log(gen.next());
	/*
	 上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，
	 即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），
	 指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止，再次调用g的next的方法，内部指针指向下个yield语句。

	换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，
	会返回一个对象，这个对象就是具有两个属性（done (done=false) 和 value (value=operand)）的 IteratorResult 对象。
	value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，
	即是否还有下一个阶段。这里说明了Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。
	* */
</script>
</html>