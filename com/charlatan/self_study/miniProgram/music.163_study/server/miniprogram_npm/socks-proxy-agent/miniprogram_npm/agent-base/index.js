module.exports = (function () {
    var __MODS__ = {}
    var __DEFINE__ = function (modId, func, req) {
        var m = { exports: {}, _tempexports: {} }
        __MODS__[modId] = { status: 0, func: func, req: req, m: m }
    }
    var __REQUIRE__ = function (modId, source) {
        if (!__MODS__[modId]) return require(source)
        if (!__MODS__[modId].status) {
            var m = __MODS__[modId].m
            m._exports = m._tempexports
            var desp = Object.getOwnPropertyDescriptor(m, 'exports')
            if (desp && desp.configurable) Object.defineProperty(m, 'exports', {
                set: function (val) {
                    if (typeof val === 'object' && val !== m._exports) {
                        m._exports.__proto__ = val.__proto__
                        Object.keys(val).forEach(function (k) { m._exports[k] = val[k] })
                    }
                    m._tempexports = val
                }, get: function () { return m._tempexports },
            })
            __MODS__[modId].status = 1
            __MODS__[modId].func(__MODS__[modId].req, m, m.exports)
        }
        return __MODS__[modId].m.exports
    }
    var __REQUIRE_WILDCARD__ = function (obj) {
        if (obj && obj.__esModule) { return obj } else {
            var newObj = {}
            if (obj != null) {
                for (var k in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, k)) newObj[k] = obj[k]
                }
            }
            newObj.default = obj
            return newObj
        }
    }
    var __REQUIRE_DEFAULT__ = function (obj) { return obj && obj.__esModule ? obj.default : obj }
    __DEFINE__(1649750013940, function (require, module, exports) {
        
        require('./patch-core')
        const inherits = require('util').inherits
        const promisify = require('es6-promisify')
        const EventEmitter = require('events').EventEmitter
        
        module.exports = Agent
        
        function isAgent (v) {
            return v && typeof v.addRequest === 'function'
        }
        
        /**
         * Base `http.Agent` implementation.
         * No pooling/keep-alive is implemented by default.
         *
         * @param {Function} callback
         * @api public
         */
        function Agent (callback, _opts) {
            if (!(this instanceof Agent)) {
                return new Agent(callback, _opts)
            }
            
            EventEmitter.call(this)
            
            // The callback gets promisified if it has 3 parameters
            // (i.e. it has a callback function) lazily
            this._promisifiedCallback = false
            
            let opts = _opts
            if ('function' === typeof callback) {
                this.callback = callback
            } else if (callback) {
                opts = callback
            }
            
            // timeout for the socket to be returned from the callback
            this.timeout = (opts && opts.timeout) || null
            
            this.options = opts
        }
        
        inherits(Agent, EventEmitter)
        
        /**
         * Override this function in your subclass!
         */
        Agent.prototype.callback = function callback (req, opts) {
            throw new Error(
                '"agent-base" has no default implementation, you must subclass and override `callback()`',
            )
        }
        
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        Agent.prototype.addRequest = function addRequest (req, _opts) {
            const ownOpts = Object.assign({}, _opts)
            
            // Set default `host` for HTTP to localhost
            if (null == ownOpts.host) {
                ownOpts.host = 'localhost'
            }
            
            // Set default `port` for HTTP if none was explicitly specified
            if (null == ownOpts.port) {
                ownOpts.port = ownOpts.secureEndpoint ? 443 : 80
            }
            
            const opts = Object.assign({}, this.options, ownOpts)
            
            if (opts.host && opts.path) {
                // If both a `host` and `path` are specified then it's most likely the
                // result of a `url.parse()` call... we need to remove the `path` portion so
                // that `net.connect()` doesn't attempt to open that as a unix socket file.
                delete opts.path
            }
            
            delete opts.agent
            delete opts.hostname
            delete opts._defaultAgent
            delete opts.defaultPort
            delete opts.createConnection
            
            // Hint to use "Connection: close"
            // XXX: non-documented `http` module API :(
            req._last = true
            req.shouldKeepAlive = false
            
            // Create the `stream.Duplex` instance
            let timeout
            let timedOut = false
            const timeoutMs = this.timeout
            const freeSocket = this.freeSocket
            
            function onerror (err) {
                if (req._hadError) return
                req.emit('error', err)
                // For Safety. Some additional errors might fire later on
                // and we need to make sure we don't double-fire the error event.
                req._hadError = true
            }
            
            function ontimeout () {
                timeout = null
                timedOut = true
                const err = new Error(
                    'A "socket" was not created for HTTP request before ' + timeoutMs + 'ms',
                )
                err.code = 'ETIMEOUT'
                onerror(err)
            }
            
            function callbackError (err) {
                if (timedOut) return
                if (timeout != null) {
                    clearTimeout(timeout)
                    timeout = null
                }
                onerror(err)
            }
            
            function onsocket (socket) {
                if (timedOut) return
                if (timeout != null) {
                    clearTimeout(timeout)
                    timeout = null
                }
                if (isAgent(socket)) {
                    // `socket` is actually an http.Agent instance, so relinquish
                    // responsibility for this `req` to the Agent from here on
                    socket.addRequest(req, opts)
                } else if (socket) {
                    function onfree () {
                        freeSocket(socket, opts)
                    }
                    
                    socket.on('free', onfree)
                    req.onSocket(socket)
                } else {
                    const err = new Error(
                        'no Duplex stream was returned to agent-base for `' + req.method + ' ' + req.path + '`',
                    )
                    onerror(err)
                }
            }
            
            if (!this._promisifiedCallback && this.callback.length >= 3) {
                // Legacy callback function - convert to a Promise
                this.callback = promisify(this.callback, this)
                this._promisifiedCallback = true
            }
            
            if (timeoutMs > 0) {
                timeout = setTimeout(ontimeout, timeoutMs)
            }
            
            try {
                Promise.resolve(this.callback(req, opts)).then(onsocket, callbackError)
            } catch (err) {
                Promise.reject(err).catch(callbackError)
            }
        }
        
        Agent.prototype.freeSocket = function freeSocket (socket, opts) {
            // TODO reuse sockets
            socket.destroy()
        }
        
    }, function (modId) {
        var map = { './patch-core': 1649750013941 }
        return __REQUIRE__(map[modId], modId)
    })
    __DEFINE__(1649750013941, function (require, module, exports) {
        
        const url = require('url')
        const https = require('https')
        
        /**
         * This currently needs to be applied to all Node.js versions
         * in order to determine if the `req` is an HTTP or HTTPS request.
         *
         * There is currently no PR attempting to move this property upstream.
         */
        https.request = (function (request) {
            return function (_options, cb) {
                let options
                if (typeof _options === 'string') {
                    options = url.parse(_options)
                } else {
                    options = Object.assign({}, _options)
                }
                if (null == options.port) {
                    options.port = 443
                }
                options.secureEndpoint = true
                return request.call(https, options, cb)
            }
        })(https.request)
        
        /**
         * This is needed for Node.js >= 9.0.0 to make sure `https.get()` uses the
         * patched `https.request()`.
         *
         * Ref: https://github.com/nodejs/node/commit/5118f31
         */
        https.get = function (options, cb) {
            const req = https.request(options, cb)
            req.end()
            return req
        }
        
    }, function (modId) {
        var map = {}
        return __REQUIRE__(map[modId], modId)
    })
    return __REQUIRE__(1649750013940)
})()
//miniprogram-npm-outsideDeps=["util","es6-promisify","events","url","https"]
//# sourceMappingURL=index.js.map
