{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar types = require('ast-types');\nvar esprima = require('esprima');\nvar escodegen = require('escodegen');\n\n/**\n * Helper functions.\n */\n\nvar n = types.namedTypes;\nvar b = types.builders;\n\n/**\n * Module exports.\n */\n\nmodule.exports = degenerator;\n\n/**\n * Turns sync JavaScript code into an JavaScript with async Generator Functions.\n *\n * @param {String} jsStr JavaScript string to convert\n * @param {Array} names Array of function names to add `yield` operators to\n * @return {String} Converted JavaScript string with Generator functions injected\n * @api public\n */\n\nfunction degenerator (jsStr, names) {\n  if (!Array.isArray(names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  }\n\n  var ast = esprima.parse(jsStr);\n\n  // duplicate the `names` array since it's rude to augment the user-provided\n  // array\n  names = names.slice(0);\n\n\n  // first pass is to find the `function` nodes and turn them into `function *`\n  // generator functions. We also add the names of the functions to the `names`\n  // array\n  types.visit(ast, {\n    visitFunction: function(path) {\n      if (path.node.id) {\n        // got a \"function\" expression/statement,\n        // convert it into a \"generator function\"\n        path.node.generator = true;\n\n        // add function name to `names` array\n        names.push(path.node.id.name);\n      }\n\n      this.traverse(path);\n    }\n  });\n\n  // second pass is for adding `yield` statements to any function\n  // invocations that match the given `names` array.\n  types.visit(ast, {\n    visitCallExpression: function(path) {\n      if (checkNames(path.node, names)) {\n        // a \"function invocation\" expression,\n        // we need to inject a `YieldExpression`\n        var name = path.name;\n        var parent = path.parent.node;\n\n        var delegate = false;\n        var expr = b.yieldExpression(path.node, delegate);\n        if (parent['arguments']) {\n          // parent is a `CallExpression` type\n          parent['arguments'][name] = expr;\n        } else {\n          parent[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n  });\n\n  return escodegen.generate(ast);\n}\n\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\nfunction checkNames (node, names) {\n  var name;\n  var callee = node.callee;\n  if ('Identifier' == callee.type) {\n    name = callee.name;\n  } else if ('MemberExpression' == callee.type) {\n    name = callee.object.name + '.' + (callee.property.name || callee.property.raw);\n  } else if ('FunctionExpression' == callee.type) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error('don\\'t know how to get name for: ' + callee.type);\n  }\n\n  // now that we have the `name`, check if any entries match in the `names` array\n  var n;\n  for (var i = 0; i < names.length; i++) {\n    n = names[i];\n    if (n.test) {\n      // regexp\n      if (n.test(name)) return true;\n    } else {\n      if (name == n) return true;\n    }\n  }\n\n  return false;\n}\n"]}