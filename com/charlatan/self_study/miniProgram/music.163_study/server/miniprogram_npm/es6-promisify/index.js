module.exports = (function () {
    var __MODS__ = {}
    var __DEFINE__ = function (modId, func, req) {
        var m = { exports: {}, _tempexports: {} }
        __MODS__[modId] = { status: 0, func: func, req: req, m: m }
    }
    var __REQUIRE__ = function (modId, source) {
        if (!__MODS__[modId]) return require(source)
        if (!__MODS__[modId].status) {
            var m = __MODS__[modId].m
            m._exports = m._tempexports
            var desp = Object.getOwnPropertyDescriptor(m, 'exports')
            if (desp && desp.configurable) Object.defineProperty(m, 'exports', {
                set: function (val) {
                    if (typeof val === 'object' && val !== m._exports) {
                        m._exports.__proto__ = val.__proto__
                        Object.keys(val).forEach(function (k) { m._exports[k] = val[k] })
                    }
                    m._tempexports = val
                }, get: function () { return m._tempexports },
            })
            __MODS__[modId].status = 1
            __MODS__[modId].func(__MODS__[modId].req, m, m.exports)
        }
        return __MODS__[modId].m.exports
    }
    var __REQUIRE_WILDCARD__ = function (obj) {
        if (obj && obj.__esModule) { return obj } else {
            var newObj = {}
            if (obj != null) {
                for (var k in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, k)) newObj[k] = obj[k]
                }
            }
            newObj.default = obj
            return newObj
        }
    }
    var __REQUIRE_DEFAULT__ = function (obj) { return obj && obj.__esModule ? obj.default : obj }
    __DEFINE__(1649750013690, function (require, module, exports) {
        
        /* global module, require */
        module.exports = function () {
            
            // Get a promise object. This may be native, or it may be polyfilled
            
            var ES6Promise = require('./promise.js')
            
            /**
             * thatLooksLikeAPromiseToMe()
             *
             * Duck-types a promise.
             *
             * @param {object} o
             * @return {bool} True if this resembles a promise
             */
            function thatLooksLikeAPromiseToMe (o) {
                return o && typeof o.then === 'function' && typeof o.catch === 'function'
            }
            
            /**
             * promisify()
             *
             * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into
             * an ES6-compatible Promise. Promisify provides a default callback of the form (error, result)
             * and rejects when `error` is truthy. You can also supply settings object as the second argument.
             *
             * @param {function} original - The function to promisify
             * @param {object} settings - Settings object
             * @param {object} settings.thisArg - A `this` context to use. If not set, assume `settings` _is_ `thisArg`
             * @param {bool} settings.multiArgs - Should multiple arguments be returned as an array?
             * @return {function} A promisified version of `original`
             */
            return function promisify (original, settings) {
                
                return function () {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key]
                    }
                    
                    var returnMultipleArguments = settings && settings.multiArgs
                    
                    var target = void 0
                    if (settings && settings.thisArg) {
                        target = settings.thisArg
                    } else if (settings) {
                        target = settings
                    }
                    
                    // Return the promisified function
                    return new ES6Promise(function (resolve, reject) {
                        
                        // Append the callback bound to the context
                        args.push(function callback (err) {
                            
                            if (err) {
                                return reject(err)
                            }
                            
                            for (var _len2 = arguments.length, values = Array(
                                _len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                                values[_key2 - 1] = arguments[_key2]
                            }
                            
                            if (false === !!returnMultipleArguments) {
                                return resolve(values[0])
                            }
                            
                            resolve(values)
                        })
                        
                        // Call the function
                        var response = original.apply(target, args)
                        
                        // If it looks like original already returns a promise,
                        // then just resolve with that promise. Hopefully, the callback function we added will just be ignored.
                        if (thatLooksLikeAPromiseToMe(response)) {
                            resolve(response)
                        }
                    })
                }
            }
        }()
    }, function (modId) {
        var map = { './promise.js': 1649750013691 }
        return __REQUIRE__(map[modId], modId)
    })
    __DEFINE__(1649750013691, function (require, module, exports) {
        
        /* global self, window, module, global, require */
        module.exports = function () {
            
            var globalObject = void 0
            
            function isFunction (x) {
                return typeof x === 'function'
            }
            
            // Seek the global object
            if (global !== undefined) {
                globalObject = global
            } else if (window !== undefined && window.document) {
                globalObject = window
            } else {
                globalObject = self
            }
            
            // Test for any native promise implementation, and if that
            // implementation appears to conform to the specificaton.
            // This code mostly nicked from the es6-promise module polyfill
            // and then fooled with.
            var hasPromiseSupport = function () {
                
                // No promise object at all, and it's a non-starter
                if (!globalObject.hasOwnProperty('Promise')) {
                    return false
                }
                
                // There is a Promise object. Does it conform to the spec?
                var P = globalObject.Promise
                
                // Some of these methods are missing from
                // Firefox/Chrome experimental implementations
                if (!P.hasOwnProperty('resolve') || !P.hasOwnProperty('reject')) {
                    return false
                }
                
                if (!P.hasOwnProperty('all') || !P.hasOwnProperty('race')) {
                    return false
                }
                
                // Older version of the spec had a resolver object
                // as the arg rather than a function
                return function () {
                    
                    var resolve = void 0
                    
                    var p = new globalObject.Promise(function (r) {
                        resolve = r
                    })
                    
                    if (p) {
                        return isFunction(resolve)
                    }
                    
                    return false
                }()
            }()
            
            // Export the native Promise implementation if it
            // looks like it matches the spec
            if (hasPromiseSupport) {
                return globalObject.Promise
            }
            
            //  Otherwise, return the es6-promise polyfill by @jaffathecake.
            return require('es6-promise').Promise
        }()
    }, function (modId) {
        var map = {}
        return __REQUIRE__(map[modId], modId)
    })
    return __REQUIRE__(1649750013690)
})()
//miniprogram-npm-outsideDeps=["es6-promise"]
//# sourceMappingURL=index.js.map
