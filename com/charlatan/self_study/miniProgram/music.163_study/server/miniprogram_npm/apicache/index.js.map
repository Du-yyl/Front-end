{
  "version": 3,
  "sources": [
    "apicache.js",
    "memory-cache.js",
    "../package.json"
  ],
  "names": [],
  "mappings": ";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "index.js",
  "sourcesContent": [
    "var url = require('url')\nvar MemoryCache = require('./memory-cache')\nvar pkg = require('../package.json')\n\nvar t = {\n  ms: 1,\n  second: 1000,\n  minute: 60000,\n  hour: 3600000,\n  day: 3600000 * 24,\n  week: 3600000 * 24 * 7,\n  month: 3600000 * 24 * 30,\n}\n\nvar instances = []\n\nvar matches = function(a) {\n  return function(b) {\n    return a === b\n  }\n}\n\nvar doesntMatch = function(a) {\n  return function(b) {\n    return !matches(a)(b)\n  }\n}\n\nvar logDuration = function(d, prefix) {\n  var str = d > 1000 ? (d / 1000).toFixed(2) + 'sec' : d + 'ms'\n  return '\\x1b[33m- ' + (prefix ? prefix + ' ' : '') + str + '\\x1b[0m'\n}\n\nfunction getSafeHeaders(res) {\n  return res.getHeaders ? res.getHeaders() : res._headers\n}\n\nfunction ApiCache() {\n  var memCache = new MemoryCache()\n\n  var globalOptions = {\n    debug: false,\n    defaultDuration: 3600000,\n    enabled: true,\n    appendKey: [],\n    jsonp: false,\n    redisClient: false,\n    headerBlacklist: [],\n    statusCodes: {\n      include: [],\n      exclude: [],\n    },\n    events: {\n      expire: undefined,\n    },\n    headers: {\n      // 'cache-control':  'no-cache' // example of header overwrite\n    },\n    trackPerformance: false,\n  }\n\n  var middlewareOptions = []\n  var instance = this\n  var index = null\n  var timers = {}\n  var performanceArray = [] // for tracking cache hit rate\n\n  instances.push(this)\n  this.id = instances.length\n\n  function debug(a, b, c, d) {\n    var arr = ['\\x1b[36m[apicache]\\x1b[0m', a, b, c, d].filter(function(arg) {\n      return arg !== undefined\n    })\n    var debugEnv = process.env.DEBUG && process.env.DEBUG.split(',').indexOf('apicache') !== -1\n\n    return (globalOptions.debug || debugEnv) && console.log.apply(null, arr)\n  }\n\n  function shouldCacheResponse(request, response, toggle) {\n    var opt = globalOptions\n    var codes = opt.statusCodes\n\n    if (!response) return false\n\n    if (toggle && !toggle(request, response)) {\n      return false\n    }\n\n    if (codes.exclude && codes.exclude.length && codes.exclude.indexOf(response.statusCode) !== -1)\n      return false\n    if (codes.include && codes.include.length && codes.include.indexOf(response.statusCode) === -1)\n      return false\n\n    return true\n  }\n\n  function addIndexEntries(key, req) {\n    var groupName = req.apicacheGroup\n\n    if (groupName) {\n      debug('group detected \"' + groupName + '\"')\n      var group = (index.groups[groupName] = index.groups[groupName] || [])\n      group.unshift(key)\n    }\n\n    index.all.unshift(key)\n  }\n\n  function filterBlacklistedHeaders(headers) {\n    return Object.keys(headers)\n      .filter(function(key) {\n        return globalOptions.headerBlacklist.indexOf(key) === -1\n      })\n      .reduce(function(acc, header) {\n        acc[header] = headers[header]\n        return acc\n      }, {})\n  }\n\n  function createCacheObject(status, headers, data, encoding) {\n    return {\n      status: status,\n      headers: filterBlacklistedHeaders(headers),\n      data: data,\n      encoding: encoding,\n      timestamp: new Date().getTime() / 1000, // seconds since epoch.  This is used to properly decrement max-age headers in cached responses.\n    }\n  }\n\n  function cacheResponse(key, value, duration) {\n    var redis = globalOptions.redisClient\n    var expireCallback = globalOptions.events.expire\n\n    if (redis && redis.connected) {\n      try {\n        redis.hset(key, 'response', JSON.stringify(value))\n        redis.hset(key, 'duration', duration)\n        redis.expire(key, duration / 1000, expireCallback || function() {})\n      } catch (err) {\n        debug('[apicache] error in redis.hset()')\n      }\n    } else {\n      memCache.add(key, value, duration, expireCallback)\n    }\n\n    // add automatic cache clearing from duration, includes max limit on setTimeout\n    timers[key] = setTimeout(function() {\n      instance.clear(key, true)\n    }, Math.min(duration, 2147483647))\n  }\n\n  function accumulateContent(res, content) {\n    if (content) {\n      if (typeof content == 'string') {\n        res._apicache.content = (res._apicache.content || '') + content\n      } else if (Buffer.isBuffer(content)) {\n        var oldContent = res._apicache.content\n\n        if (typeof oldContent === 'string') {\n          oldContent = !Buffer.from ? new Buffer(oldContent) : Buffer.from(oldContent)\n        }\n\n        if (!oldContent) {\n          oldContent = !Buffer.alloc ? new Buffer(0) : Buffer.alloc(0)\n        }\n\n        res._apicache.content = Buffer.concat(\n          [oldContent, content],\n          oldContent.length + content.length\n        )\n      } else {\n        res._apicache.content = content\n      }\n    }\n  }\n\n  function makeResponseCacheable(req, res, next, key, duration, strDuration, toggle) {\n    // monkeypatch res.end to create cache object\n    res._apicache = {\n      write: res.write,\n      writeHead: res.writeHead,\n      end: res.end,\n      cacheable: true,\n      content: undefined,\n    }\n\n    // append header overwrites if applicable\n    Object.keys(globalOptions.headers).forEach(function(name) {\n      res.setHeader(name, globalOptions.headers[name])\n    })\n\n    res.writeHead = function() {\n      // add cache control headers\n      if (!globalOptions.headers['cache-control']) {\n        if (shouldCacheResponse(req, res, toggle)) {\n          res.setHeader('cache-control', 'max-age=' + (duration / 1000).toFixed(0))\n        } else {\n          res.setHeader('cache-control', 'no-cache, no-store, must-revalidate')\n        }\n      }\n\n      res._apicache.headers = Object.assign({}, getSafeHeaders(res))\n      return res._apicache.writeHead.apply(this, arguments)\n    }\n\n    // patch res.write\n    res.write = function(content) {\n      accumulateContent(res, content)\n      return res._apicache.write.apply(this, arguments)\n    }\n\n    // patch res.end\n    res.end = function(content, encoding) {\n      if (shouldCacheResponse(req, res, toggle)) {\n        accumulateContent(res, content)\n\n        if (res._apicache.cacheable && res._apicache.content) {\n          addIndexEntries(key, req)\n          var headers = res._apicache.headers || getSafeHeaders(res)\n          var cacheObject = createCacheObject(\n            res.statusCode,\n            headers,\n            res._apicache.content,\n            encoding\n          )\n          cacheResponse(key, cacheObject, duration)\n\n          // display log entry\n          var elapsed = new Date() - req.apicacheTimer\n          debug('adding cache entry for \"' + key + '\" @ ' + strDuration, logDuration(elapsed))\n          debug('_apicache.headers: ', res._apicache.headers)\n          debug('res.getHeaders(): ', getSafeHeaders(res))\n          debug('cacheObject: ', cacheObject)\n        }\n      }\n\n      return res._apicache.end.apply(this, arguments)\n    }\n\n    next()\n  }\n\n  function sendCachedResponse(request, response, cacheObject, toggle, next, duration) {\n    if (toggle && !toggle(request, response)) {\n      return next()\n    }\n\n    var headers = getSafeHeaders(response)\n\n    Object.assign(headers, filterBlacklistedHeaders(cacheObject.headers || {}), {\n      // set properly-decremented max-age header.  This ensures that max-age is in sync with the cache expiration.\n      'cache-control':\n        'max-age=' +\n        Math.max(\n          0,\n          (duration / 1000 - (new Date().getTime() / 1000 - cacheObject.timestamp)).toFixed(0)\n        ),\n    })\n\n    // only embed apicache headers when not in production environment\n    if (process.env.NODE_ENV !== 'production') {\n      Object.assign(headers, {\n        'apicache-store': globalOptions.redisClient ? 'redis' : 'memory',\n        'apicache-version': pkg.version,\n      })\n    }\n\n    // unstringify buffers\n    var data = cacheObject.data\n    if (data && data.type === 'Buffer') {\n      data =\n        typeof data.data === 'number' ? new Buffer.alloc(data.data) : new Buffer.from(data.data)\n    }\n\n    // test Etag against If-None-Match for 304\n    var cachedEtag = cacheObject.headers.etag\n    var requestEtag = request.headers['if-none-match']\n\n    if (requestEtag && cachedEtag === requestEtag) {\n      response.writeHead(304, headers)\n      return response.end()\n    }\n\n    response.writeHead(cacheObject.status || 200, headers)\n\n    return response.end(data, cacheObject.encoding)\n  }\n\n  function syncOptions() {\n    for (var i in middlewareOptions) {\n      Object.assign(middlewareOptions[i].options, globalOptions, middlewareOptions[i].localOptions)\n    }\n  }\n\n  this.clear = function(target, isAutomatic) {\n    var group = index.groups[target]\n    var redis = globalOptions.redisClient\n\n    if (group) {\n      debug('clearing group \"' + target + '\"')\n\n      group.forEach(function(key) {\n        debug('clearing cached entry for \"' + key + '\"')\n        clearTimeout(timers[key])\n        delete timers[key]\n        if (!globalOptions.redisClient) {\n          memCache.delete(key)\n        } else {\n          try {\n            redis.del(key)\n          } catch (err) {\n            console.log('[apicache] error in redis.del(\"' + key + '\")')\n          }\n        }\n        index.all = index.all.filter(doesntMatch(key))\n      })\n\n      delete index.groups[target]\n    } else if (target) {\n      debug('clearing ' + (isAutomatic ? 'expired' : 'cached') + ' entry for \"' + target + '\"')\n      clearTimeout(timers[target])\n      delete timers[target]\n      // clear actual cached entry\n      if (!redis) {\n        memCache.delete(target)\n      } else {\n        try {\n          redis.del(target)\n        } catch (err) {\n          console.log('[apicache] error in redis.del(\"' + target + '\")')\n        }\n      }\n\n      // remove from global index\n      index.all = index.all.filter(doesntMatch(target))\n\n      // remove target from each group that it may exist in\n      Object.keys(index.groups).forEach(function(groupName) {\n        index.groups[groupName] = index.groups[groupName].filter(doesntMatch(target))\n\n        // delete group if now empty\n        if (!index.groups[groupName].length) {\n          delete index.groups[groupName]\n        }\n      })\n    } else {\n      debug('clearing entire index')\n\n      if (!redis) {\n        memCache.clear()\n      } else {\n        // clear redis keys one by one from internal index to prevent clearing non-apicache entries\n        index.all.forEach(function(key) {\n          clearTimeout(timers[key])\n          delete timers[key]\n          try {\n            redis.del(key)\n          } catch (err) {\n            console.log('[apicache] error in redis.del(\"' + key + '\")')\n          }\n        })\n      }\n      this.resetIndex()\n    }\n\n    return this.getIndex()\n  }\n\n  function parseDuration(duration, defaultDuration) {\n    if (typeof duration === 'number') return duration\n\n    if (typeof duration === 'string') {\n      var split = duration.match(/^([\\d\\.,]+)\\s?(\\w+)$/)\n\n      if (split.length === 3) {\n        var len = parseFloat(split[1])\n        var unit = split[2].replace(/s$/i, '').toLowerCase()\n        if (unit === 'm') {\n          unit = 'ms'\n        }\n\n        return (len || 1) * (t[unit] || 0)\n      }\n    }\n\n    return defaultDuration\n  }\n\n  this.getDuration = function(duration) {\n    return parseDuration(duration, globalOptions.defaultDuration)\n  }\n\n  /**\n   * Return cache performance statistics (hit rate).  Suitable for putting into a route:\n   * <code>\n   * app.get('/api/cache/performance', (req, res) => {\n   *    res.json(apicache.getPerformance())\n   * })\n   * </code>\n   */\n  this.getPerformance = function() {\n    return performanceArray.map(function(p) {\n      return p.report()\n    })\n  }\n\n  this.getIndex = function(group) {\n    if (group) {\n      return index.groups[group]\n    } else {\n      return index\n    }\n  }\n\n  this.middleware = function cache(strDuration, middlewareToggle, localOptions) {\n    var duration = instance.getDuration(strDuration)\n    var opt = {}\n\n    middlewareOptions.push({\n      options: opt,\n    })\n\n    var options = function(localOptions) {\n      if (localOptions) {\n        middlewareOptions.find(function(middleware) {\n          return middleware.options === opt\n        }).localOptions = localOptions\n      }\n\n      syncOptions()\n\n      return opt\n    }\n\n    options(localOptions)\n\n    /**\n     * A Function for non tracking performance\n     */\n    function NOOPCachePerformance() {\n      this.report = this.hit = this.miss = function() {} // noop;\n    }\n\n    /**\n     * A function for tracking and reporting hit rate.  These statistics are returned by the getPerformance() call above.\n     */\n    function CachePerformance() {\n      /**\n       * Tracks the hit rate for the last 100 requests.\n       * If there have been fewer than 100 requests, the hit rate just considers the requests that have happened.\n       */\n      this.hitsLast100 = new Uint8Array(100 / 4) // each hit is 2 bits\n\n      /**\n       * Tracks the hit rate for the last 1000 requests.\n       * If there have been fewer than 1000 requests, the hit rate just considers the requests that have happened.\n       */\n      this.hitsLast1000 = new Uint8Array(1000 / 4) // each hit is 2 bits\n\n      /**\n       * Tracks the hit rate for the last 10000 requests.\n       * If there have been fewer than 10000 requests, the hit rate just considers the requests that have happened.\n       */\n      this.hitsLast10000 = new Uint8Array(10000 / 4) // each hit is 2 bits\n\n      /**\n       * Tracks the hit rate for the last 100000 requests.\n       * If there have been fewer than 100000 requests, the hit rate just considers the requests that have happened.\n       */\n      this.hitsLast100000 = new Uint8Array(100000 / 4) // each hit is 2 bits\n\n      /**\n       * The number of calls that have passed through the middleware since the server started.\n       */\n      this.callCount = 0\n\n      /**\n       * The total number of hits since the server started\n       */\n      this.hitCount = 0\n\n      /**\n       * The key from the last cache hit.  This is useful in identifying which route these statistics apply to.\n       */\n      this.lastCacheHit = null\n\n      /**\n       * The key from the last cache miss.  This is useful in identifying which route these statistics apply to.\n       */\n      this.lastCacheMiss = null\n\n      /**\n       * Return performance statistics\n       */\n      this.report = function() {\n        return {\n          lastCacheHit: this.lastCacheHit,\n          lastCacheMiss: this.lastCacheMiss,\n          callCount: this.callCount,\n          hitCount: this.hitCount,\n          missCount: this.callCount - this.hitCount,\n          hitRate: this.callCount == 0 ? null : this.hitCount / this.callCount,\n          hitRateLast100: this.hitRate(this.hitsLast100),\n          hitRateLast1000: this.hitRate(this.hitsLast1000),\n          hitRateLast10000: this.hitRate(this.hitsLast10000),\n          hitRateLast100000: this.hitRate(this.hitsLast100000),\n        }\n      }\n\n      /**\n       * Computes a cache hit rate from an array of hits and misses.\n       * @param {Uint8Array} array An array representing hits and misses.\n       * @returns a number between 0 and 1, or null if the array has no hits or misses\n       */\n      this.hitRate = function(array) {\n        var hits = 0\n        var misses = 0\n        for (var i = 0; i < array.length; i++) {\n          var n8 = array[i]\n          for (j = 0; j < 4; j++) {\n            switch (n8 & 3) {\n              case 1:\n                hits++\n                break\n              case 2:\n                misses++\n                break\n            }\n            n8 >>= 2\n          }\n        }\n        var total = hits + misses\n        if (total == 0) return null\n        return hits / total\n      }\n\n      /**\n       * Record a hit or miss in the given array.  It will be recorded at a position determined\n       * by the current value of the callCount variable.\n       * @param {Uint8Array} array An array representing hits and misses.\n       * @param {boolean} hit true for a hit, false for a miss\n       * Each element in the array is 8 bits, and encodes 4 hit/miss records.\n       * Each hit or miss is encoded as to bits as follows:\n       * 00 means no hit or miss has been recorded in these bits\n       * 01 encodes a hit\n       * 10 encodes a miss\n       */\n      this.recordHitInArray = function(array, hit) {\n        var arrayIndex = ~~(this.callCount / 4) % array.length\n        var bitOffset = (this.callCount % 4) * 2 // 2 bits per record, 4 records per uint8 array element\n        var clearMask = ~(3 << bitOffset)\n        var record = (hit ? 1 : 2) << bitOffset\n        array[arrayIndex] = (array[arrayIndex] & clearMask) | record\n      }\n\n      /**\n       * Records the hit or miss in the tracking arrays and increments the call count.\n       * @param {boolean} hit true records a hit, false records a miss\n       */\n      this.recordHit = function(hit) {\n        this.recordHitInArray(this.hitsLast100, hit)\n        this.recordHitInArray(this.hitsLast1000, hit)\n        this.recordHitInArray(this.hitsLast10000, hit)\n        this.recordHitInArray(this.hitsLast100000, hit)\n        if (hit) this.hitCount++\n        this.callCount++\n      }\n\n      /**\n       * Records a hit event, setting lastCacheMiss to the given key\n       * @param {string} key The key that had the cache hit\n       */\n      this.hit = function(key) {\n        this.recordHit(true)\n        this.lastCacheHit = key\n      }\n\n      /**\n       * Records a miss event, setting lastCacheMiss to the given key\n       * @param {string} key The key that had the cache miss\n       */\n      this.miss = function(key) {\n        this.recordHit(false)\n        this.lastCacheMiss = key\n      }\n    }\n\n    var perf = globalOptions.trackPerformance ? new CachePerformance() : new NOOPCachePerformance()\n\n    performanceArray.push(perf)\n\n    var cache = function(req, res, next) {\n      function bypass() {\n        debug('bypass detected, skipping cache.')\n        return next()\n      }\n\n      // initial bypass chances\n      if (!opt.enabled) return bypass()\n      if (req.headers['x-apicache-bypass'] || req.headers['x-apicache-force-fetch']) return bypass()\n\n      // REMOVED IN 0.11.1 TO CORRECT MIDDLEWARE TOGGLE EXECUTE ORDER\n      // if (typeof middlewareToggle === 'function') {\n      //   if (!middlewareToggle(req, res)) return bypass()\n      // } else if (middlewareToggle !== undefined && !middlewareToggle) {\n      //   return bypass()\n      // }\n\n      // embed timer\n      req.apicacheTimer = new Date()\n\n      // In Express 4.x the url is ambigious based on where a router is mounted.  originalUrl will give the full Url\n      var key = req.originalUrl || req.url\n\n      // Remove querystring from key if jsonp option is enabled\n      if (opt.jsonp) {\n        key = url.parse(key).pathname\n      }\n\n      // add appendKey (either custom function or response path)\n      if (typeof opt.appendKey === 'function') {\n        key += '$$appendKey=' + opt.appendKey(req, res)\n      } else if (opt.appendKey.length > 0) {\n        var appendKey = req\n\n        for (var i = 0; i < opt.appendKey.length; i++) {\n          appendKey = appendKey[opt.appendKey[i]]\n        }\n        key += '$$appendKey=' + appendKey\n      }\n\n      // attempt cache hit\n      var redis = opt.redisClient\n      var cached = !redis ? memCache.getValue(key) : null\n\n      // send if cache hit from memory-cache\n      if (cached) {\n        var elapsed = new Date() - req.apicacheTimer\n        debug('sending cached (memory-cache) version of', key, logDuration(elapsed))\n\n        perf.hit(key)\n        return sendCachedResponse(req, res, cached, middlewareToggle, next, duration)\n      }\n\n      // send if cache hit from redis\n      if (redis && redis.connected) {\n        try {\n          redis.hgetall(key, function(err, obj) {\n            if (!err && obj && obj.response) {\n              var elapsed = new Date() - req.apicacheTimer\n              debug('sending cached (redis) version of', key, logDuration(elapsed))\n\n              perf.hit(key)\n              return sendCachedResponse(\n                req,\n                res,\n                JSON.parse(obj.response),\n                middlewareToggle,\n                next,\n                duration\n              )\n            } else {\n              perf.miss(key)\n              return makeResponseCacheable(\n                req,\n                res,\n                next,\n                key,\n                duration,\n                strDuration,\n                middlewareToggle\n              )\n            }\n          })\n        } catch (err) {\n          // bypass redis on error\n          perf.miss(key)\n          return makeResponseCacheable(req, res, next, key, duration, strDuration, middlewareToggle)\n        }\n      } else {\n        perf.miss(key)\n        return makeResponseCacheable(req, res, next, key, duration, strDuration, middlewareToggle)\n      }\n    }\n\n    cache.options = options\n\n    return cache\n  }\n\n  this.options = function(options) {\n    if (options) {\n      Object.assign(globalOptions, options)\n      syncOptions()\n\n      if ('defaultDuration' in options) {\n        // Convert the default duration to a number in milliseconds (if needed)\n        globalOptions.defaultDuration = parseDuration(globalOptions.defaultDuration, 3600000)\n      }\n\n      if (globalOptions.trackPerformance) {\n        debug('WARNING: using trackPerformance flag can cause high memory usage!')\n      }\n\n      return this\n    } else {\n      return globalOptions\n    }\n  }\n\n  this.resetIndex = function() {\n    index = {\n      all: [],\n      groups: {},\n    }\n  }\n\n  this.newInstance = function(config) {\n    var instance = new ApiCache()\n\n    if (config) {\n      instance.options(config)\n    }\n\n    return instance\n  }\n\n  this.clone = function() {\n    return this.newInstance(this.options())\n  }\n\n  // initialize index\n  this.resetIndex()\n}\n\nmodule.exports = new ApiCache()\n",
    "function MemoryCache() {\n  this.cache = {}\n  this.size = 0\n}\n\nMemoryCache.prototype.add = function(key, value, time, timeoutCallback) {\n  var old = this.cache[key]\n  var instance = this\n\n  var entry = {\n    value: value,\n    expire: time + Date.now(),\n    timeout: setTimeout(function() {\n      instance.delete(key)\n      return timeoutCallback && typeof timeoutCallback === 'function' && timeoutCallback(value, key)\n    }, time)\n  }\n\n  this.cache[key] = entry\n  this.size = Object.keys(this.cache).length\n\n  return entry\n}\n\nMemoryCache.prototype.delete = function(key) {\n  var entry = this.cache[key]\n\n  if (entry) {\n    clearTimeout(entry.timeout)\n  }\n\n  delete this.cache[key]\n\n  this.size = Object.keys(this.cache).length\n\n  return null\n}\n\nMemoryCache.prototype.get = function(key) {\n  var entry = this.cache[key]\n\n  return entry\n}\n\nMemoryCache.prototype.getValue = function(key) {\n  var entry = this.get(key)\n\n  return entry && entry.value\n}\n\nMemoryCache.prototype.clear = function() {\n  Object.keys(this.cache).forEach(function(key) {\n    this.delete(key)\n  }, this)\n\n  return true\n}\n\nmodule.exports = MemoryCache\n",
    "module.exports = {\n  \"_from\": \"apicache@^1.5.2\",\n  \"_id\": \"apicache@1.5.3\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha1-iXezWL99V51V/j0YPJB65dvPs1c=\",\n  \"_location\": \"/apicache\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"apicache@^1.5.2\",\n    \"name\": \"apicache\",\n    \"escapedName\": \"apicache\",\n    \"rawSpec\": \"^1.5.2\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^1.5.2\"\n  },\n  \"_requiredBy\": [\n    \"/\"\n  ],\n  \"_resolved\": \"https://registry.npm.taobao.org/apicache/download/apicache-1.5.3.tgz\",\n  \"_shasum\": \"8977b358bf7d579d55fe3d183c907ae5dbcfb357\",\n  \"_spec\": \"apicache@^1.5.2\",\n  \"_where\": \"C:\\\\Users\\\\13852\\\\Desktop\\\\网易项目\\\\NeteaseCloudMusicApi\",\n  \"author\": {\n    \"name\": \"Kevin R. Whitley\",\n    \"email\": \"krwhitley@gmail.com\",\n    \"url\": \"http://krwhitley.com\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/kwhitley/apicache/issues\",\n    \"email\": \"krwhitley@gmail.com\"\n  },\n  \"bundleDependencies\": false,\n  \"dependencies\": {},\n  \"deprecated\": false,\n  \"description\": \"An ultra-simplified API response caching middleware for Express/Node using plain-english durations.\",\n  \"devDependencies\": {\n    \"chai\": \"^4.2.0\",\n    \"compression\": \"^1.7.4\",\n    \"coveralls\": \"^3.0.6\",\n    \"eslint\": \"^4.18.0\",\n    \"express\": \"^4.17.1\",\n    \"fakeredis\": \"^2.0.0\",\n    \"husky\": \"^3.0.4\",\n    \"mocha\": \"^7.0.0\",\n    \"nyc\": \"^13.3.0\",\n    \"prettier\": \"^1.18.2\",\n    \"pretty-quick\": \"^1.11.1\",\n    \"restify\": \"^7.7.0\",\n    \"restify-etag-cache\": \"^1.0.12\",\n    \"supertest\": \"^4.0.2\"\n  },\n  \"engines\": {\n    \"node\": \">=6.2.0 <13\"\n  },\n  \"homepage\": \"https://github.com/kwhitley/apicache#readme\",\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"pretty-quick --staged && npm run test\"\n    }\n  },\n  \"keywords\": [\n    \"cache\",\n    \"API\",\n    \"redis\",\n    \"memcache\",\n    \"response\",\n    \"express\",\n    \"JSON\",\n    \"duration\",\n    \"middleware\",\n    \"memory\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"./src/apicache.js\",\n  \"name\": \"apicache\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/kwhitley/apicache.git\"\n  },\n  \"scripts\": {\n    \"coverage\": \"nyc report --reporter=text-lcov | coveralls\",\n    \"lint\": \"eslint .\",\n    \"prepublish\": \"npm run test\",\n    \"pretest\": \"npm run lint\",\n    \"test\": \"nyc mocha $(find test -name '*.test.js') --recursive\",\n    \"test:watch\": \"npm run test -- --watch\"\n  },\n  \"version\": \"1.5.3\"\n}\n"
  ]
}
