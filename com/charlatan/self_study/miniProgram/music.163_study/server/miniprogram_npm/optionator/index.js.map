{"version":3,"sources":["index.js","util.js","help.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// Generated by LiveScript 1.6.0\n(function(){\n  var VERSION, ref$, id, map, compact, any, groupBy, partition, chars, isItNaN, keys, Obj, camelize, deepIs, closestString, nameToRaw, dasherize, naturalJoin, generateHelp, generateHelpForOption, parsedTypeCheck, parseType, parseLevn, camelizeKeys, parseString, main, toString$ = {}.toString, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};\n  VERSION = '0.8.3';\n  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, partition = ref$.partition, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;\n  deepIs = require('deep-is');\n  ref$ = require('./util'), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;\n  ref$ = require('./help'), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;\n  ref$ = require('type-check'), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;\n  parseLevn = require('levn').parsedTypeParse;\n  camelizeKeys = function(obj){\n    var key, value, resultObj$ = {};\n    for (key in obj) {\n      value = obj[key];\n      resultObj$[camelize(key)] = value;\n    }\n    return resultObj$;\n  };\n  parseString = function(string){\n    var assignOpt, regex, replaceRegex, result;\n    assignOpt = '--?[a-zA-Z][-a-z-A-Z0-9]*=';\n    regex = RegExp('(?:' + assignOpt + ')?(?:\\'(?:\\\\\\\\\\'|[^\\'])+\\'|\"(?:\\\\\\\\\"|[^\"])+\")|[^\\'\"\\\\s]+', 'g');\n    replaceRegex = RegExp('^(' + assignOpt + ')?[\\'\"]([\\\\s\\\\S]*)[\\'\"]$');\n    result = map(function(it){\n      return it.replace(replaceRegex, '$1$2');\n    }, string.match(regex) || []);\n    return result;\n  };\n  main = function(libOptions){\n    var opts, defaults, required, traverse, getOption, parse;\n    opts = {};\n    defaults = {};\n    required = [];\n    if (toString$.call(libOptions.stdout).slice(8, -1) === 'Undefined') {\n      libOptions.stdout = process.stdout;\n    }\n    libOptions.positionalAnywhere == null && (libOptions.positionalAnywhere = true);\n    libOptions.typeAliases == null && (libOptions.typeAliases = {});\n    libOptions.defaults == null && (libOptions.defaults = {});\n    if (libOptions.concatRepeatedArrays != null) {\n      libOptions.defaults.concatRepeatedArrays = libOptions.concatRepeatedArrays;\n    }\n    if (libOptions.mergeRepeatedObjects != null) {\n      libOptions.defaults.mergeRepeatedObjects = libOptions.mergeRepeatedObjects;\n    }\n    traverse = function(options){\n      var i$, len$, option, name, k, ref$, v, type, that, e, parsedPossibilities, parsedType, j$, len1$, possibility, rawDependsType, dependsOpts, dependsType, cra, alias, shortNames, longNames;\n      if (toString$.call(options).slice(8, -1) !== 'Array') {\n        throw new Error('No options defined.');\n      }\n      for (i$ = 0, len$ = options.length; i$ < len$; ++i$) {\n        option = options[i$];\n        if (option.heading == null) {\n          name = option.option;\n          if (opts[name] != null) {\n            throw new Error(\"Option '\" + name + \"' already defined.\");\n          }\n          for (k in ref$ = libOptions.defaults) {\n            v = ref$[k];\n            option[k] == null && (option[k] = v);\n          }\n          if (option.type === 'Boolean') {\n            option.boolean == null && (option.boolean = true);\n          }\n          if (option.parsedType == null) {\n            if (!option.type) {\n              throw new Error(\"No type defined for option '\" + name + \"'.\");\n            }\n            try {\n              type = (that = libOptions.typeAliases[option.type]) != null\n                ? that\n                : option.type;\n              option.parsedType = parseType(type);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing type '\" + option.type + \"': \" + e.message);\n            }\n          }\n          if (option['default']) {\n            try {\n              defaults[name] = parseLevn(option.parsedType, option['default']);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing default value '\" + option['default'] + \"' for type '\" + option.type + \"': \" + e.message);\n            }\n          }\n          if (option['enum'] && !option.parsedPossiblities) {\n            parsedPossibilities = [];\n            parsedType = option.parsedType;\n            for (j$ = 0, len1$ = (ref$ = option['enum']).length; j$ < len1$; ++j$) {\n              possibility = ref$[j$];\n              try {\n                parsedPossibilities.push(parseLevn(parsedType, possibility));\n              } catch (e$) {\n                e = e$;\n                throw new Error(\"Option '\" + name + \"': Error parsing enum value '\" + possibility + \"' for type '\" + option.type + \"': \" + e.message);\n              }\n            }\n            option.parsedPossibilities = parsedPossibilities;\n          }\n          if (that = option.dependsOn) {\n            if (that.length) {\n              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[0], dependsOpts = slice$.call(ref$, 1);\n              dependsType = rawDependsType.toLowerCase();\n              if (dependsOpts.length) {\n                if (dependsType === 'and' || dependsType === 'or') {\n                  option.dependsOn = [dependsType].concat(arrayFrom$(dependsOpts));\n                } else {\n                  throw new Error(\"Option '\" + name + \"': If you have more than one dependency, you must specify either 'and' or 'or'\");\n                }\n              } else {\n                if ((ref$ = dependsType.toLowerCase()) === 'and' || ref$ === 'or') {\n                  option.dependsOn = null;\n                } else {\n                  option.dependsOn = ['and', rawDependsType];\n                }\n              }\n            } else {\n              option.dependsOn = null;\n            }\n          }\n          if (option.required) {\n            required.push(name);\n          }\n          opts[name] = option;\n          if (option.concatRepeatedArrays != null) {\n            cra = option.concatRepeatedArrays;\n            if ('Boolean' === toString$.call(cra).slice(8, -1)) {\n              option.concatRepeatedArrays = [cra, {}];\n            } else if (cra.length === 1) {\n              option.concatRepeatedArrays = [cra[0], {}];\n            } else if (cra.length !== 2) {\n              throw new Error(\"Invalid setting for concatRepeatedArrays\");\n            }\n          }\n          if (option.alias || option.aliases) {\n            if (name === 'NUM') {\n              throw new Error(\"-NUM option can't have aliases.\");\n            }\n            if (option.alias) {\n              option.aliases == null && (option.aliases = [].concat(option.alias));\n            }\n            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ < len1$; ++j$) {\n              alias = ref$[j$];\n              if (opts[alias] != null) {\n                throw new Error(\"Option '\" + alias + \"' already defined.\");\n              }\n              opts[alias] = option;\n            }\n            ref$ = partition(fn$, option.aliases), shortNames = ref$[0], longNames = ref$[1];\n            option.shortNames == null && (option.shortNames = shortNames);\n            option.longNames == null && (option.longNames = longNames);\n          }\n          if ((!option.aliases || option.shortNames.length === 0) && option.type === 'Boolean' && option['default'] === 'true') {\n            option.negateName = true;\n          }\n        }\n      }\n      function fn$(it){\n        return it.length === 1;\n      }\n    };\n    traverse(libOptions.options);\n    getOption = function(name){\n      var opt, possiblyMeant;\n      opt = opts[name];\n      if (opt == null) {\n        possiblyMeant = closestString(keys(opts), name);\n        throw new Error(\"Invalid option '\" + nameToRaw(name) + \"'\" + (possiblyMeant ? \" - perhaps you meant '\" + nameToRaw(possiblyMeant) + \"'?\" : '.'));\n      }\n      return opt;\n    };\n    parse = function(input, arg$){\n      var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;\n      slice = (arg$ != null\n        ? arg$\n        : {}).slice;\n      obj = {};\n      positional = [];\n      restPositional = false;\n      overrideRequired = false;\n      prop = null;\n      setValue = function(name, value){\n        var opt, val, cra, e, currentType;\n        opt = getOption(name);\n        if (opt.boolean) {\n          val = value;\n        } else {\n          try {\n            cra = opt.concatRepeatedArrays;\n            if (cra != null && cra[0] && cra[1].oneValuePerFlag && opt.parsedType.length === 1 && opt.parsedType[0].structure === 'array') {\n              val = [parseLevn(opt.parsedType[0].of, value)];\n            } else {\n              val = parseLevn(opt.parsedType, value);\n            }\n          } catch (e$) {\n            e = e$;\n            throw new Error(\"Invalid value for option '\" + name + \"' - expected type \" + opt.type + \", received value: \" + value + \".\");\n          }\n          if (opt['enum'] && !any(function(it){\n            return deepIs(it, val);\n          }, opt.parsedPossibilities)) {\n            throw new Error(\"Option \" + name + \": '\" + val + \"' not one of \" + naturalJoin(opt['enum']) + \".\");\n          }\n        }\n        currentType = toString$.call(obj[name]).slice(8, -1);\n        if (obj[name] != null) {\n          if (opt.concatRepeatedArrays != null && opt.concatRepeatedArrays[0] && currentType === 'Array') {\n            obj[name] = obj[name].concat(val);\n          } else if (opt.mergeRepeatedObjects && currentType === 'Object') {\n            import$(obj[name], val);\n          } else {\n            obj[name] = val;\n          }\n        } else {\n          obj[name] = val;\n        }\n        if (opt.restPositional) {\n          restPositional = true;\n        }\n        if (opt.overrideRequired) {\n          overrideRequired = true;\n        }\n      };\n      setDefaults = function(){\n        var name, ref$, value;\n        for (name in ref$ = defaults) {\n          value = ref$[name];\n          if (obj[name] == null) {\n            obj[name] = value;\n          }\n        }\n      };\n      checkRequired = function(){\n        var i$, ref$, len$, name;\n        if (overrideRequired) {\n          return;\n        }\n        for (i$ = 0, len$ = (ref$ = required).length; i$ < len$; ++i$) {\n          name = ref$[i$];\n          if (!obj[name]) {\n            throw new Error(\"Option \" + nameToRaw(name) + \" is required.\");\n          }\n        }\n      };\n      mutuallyExclusiveError = function(first, second){\n        throw new Error(\"The options \" + nameToRaw(first) + \" and \" + nameToRaw(second) + \" are mutually exclusive - you cannot use them at the same time.\");\n      };\n      checkMutuallyExclusive = function(){\n        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;\n        rules = libOptions.mutuallyExclusive;\n        if (!rules) {\n          return;\n        }\n        for (i$ = 0, len$ = rules.length; i$ < len$; ++i$) {\n          rule = rules[i$];\n          present = null;\n          for (j$ = 0, len1$ = rule.length; j$ < len1$; ++j$) {\n            element = rule[j$];\n            if (toString$.call(element).slice(8, -1) === 'Array') {\n              for (k$ = 0, len2$ = element.length; k$ < len2$; ++k$) {\n                opt = element[k$];\n                if (opt in obj) {\n                  if (present != null) {\n                    mutuallyExclusiveError(present, opt);\n                  } else {\n                    present = opt;\n                    break;\n                  }\n                }\n              }\n            } else {\n              if (element in obj) {\n                if (present != null) {\n                  mutuallyExclusiveError(present, element);\n                } else {\n                  present = element;\n                }\n              }\n            }\n          }\n        }\n      };\n      checkDependency = function(option){\n        var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;\n        dependsOn = option.dependsOn;\n        if (!dependsOn || option.dependenciesMet) {\n          return true;\n        }\n        type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);\n        for (i$ = 0, len$ = targetOptionNames.length; i$ < len$; ++i$) {\n          targetOptionName = targetOptionNames[i$];\n          targetOption = obj[targetOptionName];\n          if (targetOption && checkDependency(targetOption)) {\n            if (type === 'or') {\n              return true;\n            }\n          } else if (type === 'and') {\n            throw new Error(\"The option '\" + option.option + \"' did not have its dependencies met.\");\n          }\n        }\n        if (type === 'and') {\n          return true;\n        } else {\n          throw new Error(\"The option '\" + option.option + \"' did not meet any of its dependencies.\");\n        }\n      };\n      checkDependencies = function(){\n        var name;\n        for (name in obj) {\n          checkDependency(opts[name]);\n        }\n      };\n      checkProp = function(){\n        if (prop) {\n          throw new Error(\"Value for '\" + prop + \"' of type '\" + getOption(prop).type + \"' required.\");\n        }\n      };\n      switch (toString$.call(input).slice(8, -1)) {\n      case 'String':\n        args = parseString(input.slice(slice != null ? slice : 0));\n        break;\n      case 'Array':\n        args = input.slice(slice != null ? slice : 2);\n        break;\n      case 'Object':\n        obj = {};\n        for (key in input) {\n          value = input[key];\n          if (key !== '_') {\n            option = getOption(dasherize(key));\n            if (parsedTypeCheck(option.parsedType, value)) {\n              obj[option.option] = value;\n            } else {\n              throw new Error(\"Option '\" + option.option + \"': Invalid type for '\" + value + \"' - expected type '\" + option.type + \"'.\");\n            }\n          }\n        }\n        checkMutuallyExclusive();\n        checkDependencies();\n        setDefaults();\n        checkRequired();\n        return ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;\n      default:\n        throw new Error(\"Invalid argument to 'parse': \" + input + \".\");\n      }\n      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n        arg = args[i$];\n        if (arg === '--') {\n          restPositional = true;\n        } else if (restPositional) {\n          positional.push(arg);\n        } else {\n          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {\n            result = that;\n            checkProp();\n            short = result[1].length === 1;\n            argName = result[2];\n            usingAssign = result[3] != null;\n            val = result[4];\n            if (usingAssign && val == null) {\n              throw new Error(\"No value for '\" + argName + \"' specified.\");\n            }\n            if (short) {\n              flags = chars(argName);\n              len = flags.length;\n              for (j$ = 0, len1$ = flags.length; j$ < len1$; ++j$) {\n                i = j$;\n                flag = flags[j$];\n                opt = getOption(flag);\n                name = opt.option;\n                if (restPositional) {\n                  positional.push(flag);\n                } else if (i === len - 1) {\n                  if (usingAssign) {\n                    valPrime = opt.boolean ? parseLevn([{\n                      type: 'Boolean'\n                    }], val) : val;\n                    setValue(name, valPrime);\n                  } else if (opt.boolean) {\n                    setValue(name, true);\n                  } else {\n                    prop = name;\n                  }\n                } else if (opt.boolean) {\n                  setValue(name, true);\n                } else {\n                  throw new Error(\"Can't set argument '\" + flag + \"' when not last flag in a group of short flags.\");\n                }\n              }\n            } else {\n              negated = false;\n              if (that = argName.match(/^no-(.+)$/)) {\n                negated = true;\n                noedName = that[1];\n                opt = getOption(noedName);\n              } else {\n                opt = getOption(argName);\n              }\n              name = opt.option;\n              if (opt.boolean) {\n                valPrime = usingAssign ? parseLevn([{\n                  type: 'Boolean'\n                }], val) : true;\n                if (negated) {\n                  setValue(name, !valPrime);\n                } else {\n                  setValue(name, valPrime);\n                }\n              } else {\n                if (negated) {\n                  throw new Error(\"Only use 'no-' prefix for Boolean options, not with '\" + noedName + \"'.\");\n                }\n                if (usingAssign) {\n                  setValue(name, val);\n                } else {\n                  prop = name;\n                }\n              }\n            }\n          } else if (that = arg.match(/^-([0-9]+(?:\\.[0-9]+)?)$/)) {\n            opt = opts.NUM;\n            if (!opt) {\n              throw new Error('No -NUM option defined.');\n            }\n            setValue(opt.option, that[1]);\n          } else {\n            if (prop) {\n              setValue(prop, arg);\n              prop = null;\n            } else {\n              positional.push(arg);\n              if (!libOptions.positionalAnywhere) {\n                restPositional = true;\n              }\n            }\n          }\n        }\n      }\n      checkProp();\n      checkMutuallyExclusive();\n      checkDependencies();\n      setDefaults();\n      checkRequired();\n      return ref$ = camelizeKeys(obj), ref$._ = positional, ref$;\n    };\n    return {\n      parse: parse,\n      parseArgv: function(it){\n        return parse(it, {\n          slice: 2\n        });\n      },\n      generateHelp: generateHelp(libOptions),\n      generateHelpForOption: generateHelpForOption(getOption, libOptions)\n    };\n  };\n  main.VERSION = VERSION;\n  module.exports = main;\n  function import$(obj, src){\n    var own = {}.hasOwnProperty;\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n    return obj;\n  }\n}).call(this);\n","// Generated by LiveScript 1.6.0\n(function(){\n  var prelude, map, sortBy, fl, closestString, nameToRaw, dasherize, naturalJoin;\n  prelude = require('prelude-ls'), map = prelude.map, sortBy = prelude.sortBy;\n  fl = require('fast-levenshtein');\n  closestString = function(possibilities, input){\n    var distances, ref$, string, distance;\n    if (!possibilities.length) {\n      return;\n    }\n    distances = map(function(it){\n      var ref$, longer, shorter;\n      ref$ = input.length > it.length\n        ? [input, it]\n        : [it, input], longer = ref$[0], shorter = ref$[1];\n      return {\n        string: it,\n        distance: fl.get(longer, shorter)\n      };\n    })(\n    possibilities);\n    ref$ = sortBy(function(it){\n      return it.distance;\n    }, distances)[0], string = ref$.string, distance = ref$.distance;\n    return string;\n  };\n  nameToRaw = function(name){\n    if (name.length === 1 || name === 'NUM') {\n      return \"-\" + name;\n    } else {\n      return \"--\" + name;\n    }\n  };\n  dasherize = function(string){\n    if (/^[A-Z]/.test(string)) {\n      return string;\n    } else {\n      return prelude.dasherize(string);\n    }\n  };\n  naturalJoin = function(array){\n    if (array.length < 3) {\n      return array.join(' or ');\n    } else {\n      return array.slice(0, -1).join(', ') + \", or \" + array[array.length - 1];\n    }\n  };\n  module.exports = {\n    closestString: closestString,\n    nameToRaw: nameToRaw,\n    dasherize: dasherize,\n    naturalJoin: naturalJoin\n  };\n}).call(this);\n","// Generated by LiveScript 1.6.0\n(function(){\n  var ref$, id, find, sort, min, max, map, unlines, nameToRaw, dasherize, naturalJoin, wordWrap, wordwrap, getPreText, setHelpStyleDefaults, generateHelpForOption, generateHelp;\n  ref$ = require('prelude-ls'), id = ref$.id, find = ref$.find, sort = ref$.sort, min = ref$.min, max = ref$.max, map = ref$.map, unlines = ref$.unlines;\n  ref$ = require('./util'), nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;\n  wordWrap = require('word-wrap');\n  wordwrap = function(a, b){\n    var ref$, indent, width;\n    ref$ = b === undefined\n      ? ['', a - 1]\n      : [repeatString$(' ', a), b - a - 1], indent = ref$[0], width = ref$[1];\n    return function(text){\n      return wordWrap(text, {\n        indent: indent,\n        width: width,\n        trim: true\n      });\n    };\n  };\n  getPreText = function(option, arg$, maxWidth){\n    var mainName, shortNames, ref$, longNames, type, description, aliasSeparator, typeSeparator, initialIndent, names, namesString, namesStringLen, typeSeparatorString, typeSeparatorStringLen, wrap;\n    mainName = option.option, shortNames = (ref$ = option.shortNames) != null\n      ? ref$\n      : [], longNames = (ref$ = option.longNames) != null\n      ? ref$\n      : [], type = option.type, description = option.description;\n    aliasSeparator = arg$.aliasSeparator, typeSeparator = arg$.typeSeparator, initialIndent = arg$.initialIndent;\n    if (option.negateName) {\n      mainName = \"no-\" + mainName;\n      if (longNames) {\n        longNames = map(function(it){\n          return \"no-\" + it;\n        }, longNames);\n      }\n    }\n    names = mainName.length === 1\n      ? [mainName].concat(shortNames, longNames)\n      : shortNames.concat([mainName], longNames);\n    namesString = map(nameToRaw, names).join(aliasSeparator);\n    namesStringLen = namesString.length;\n    typeSeparatorString = mainName === 'NUM' ? '::' : typeSeparator;\n    typeSeparatorStringLen = typeSeparatorString.length;\n    if (maxWidth != null && !option.boolean && initialIndent + namesStringLen + typeSeparatorStringLen + type.length > maxWidth) {\n      wrap = wordwrap(initialIndent + namesStringLen + typeSeparatorStringLen, maxWidth);\n      return namesString + \"\" + typeSeparatorString + wrap(type).replace(/^\\s+/, '');\n    } else {\n      return namesString + \"\" + (option.boolean\n        ? ''\n        : typeSeparatorString + \"\" + type);\n    }\n  };\n  setHelpStyleDefaults = function(helpStyle){\n    helpStyle.aliasSeparator == null && (helpStyle.aliasSeparator = ', ');\n    helpStyle.typeSeparator == null && (helpStyle.typeSeparator = ' ');\n    helpStyle.descriptionSeparator == null && (helpStyle.descriptionSeparator = '  ');\n    helpStyle.initialIndent == null && (helpStyle.initialIndent = 2);\n    helpStyle.secondaryIndent == null && (helpStyle.secondaryIndent = 4);\n    helpStyle.maxPadFactor == null && (helpStyle.maxPadFactor = 1.5);\n  };\n  generateHelpForOption = function(getOption, arg$){\n    var stdout, helpStyle, ref$;\n    stdout = arg$.stdout, helpStyle = (ref$ = arg$.helpStyle) != null\n      ? ref$\n      : {};\n    setHelpStyleDefaults(helpStyle);\n    return function(optionName){\n      var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString, exampleString, examples, seperator;\n      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;\n      wrap = maxWidth ? wordwrap(maxWidth) : id;\n      try {\n        option = getOption(dasherize(optionName));\n      } catch (e$) {\n        e = e$;\n        return e.message;\n      }\n      pre = getPreText(option, helpStyle);\n      defaultString = option['default'] && !option.negateName ? \"\\ndefault: \" + option['default'] : '';\n      restPositionalString = option.restPositional ? 'Everything after this option is considered a positional argument, even if it looks like an option.' : '';\n      description = option.longDescription || option.description && sentencize(option.description);\n      fullDescription = description && restPositionalString\n        ? description + \" \" + restPositionalString\n        : (that = description || restPositionalString) ? that : '';\n      preDescription = 'description:';\n      descriptionString = !fullDescription\n        ? ''\n        : maxWidth && fullDescription.length - 1 - preDescription.length > maxWidth\n          ? \"\\n\" + preDescription + \"\\n\" + wrap(fullDescription)\n          : \"\\n\" + preDescription + \" \" + fullDescription;\n      exampleString = (that = option.example) ? (examples = [].concat(that), examples.length > 1\n        ? \"\\nexamples:\\n\" + unlines(examples)\n        : \"\\nexample: \" + examples[0]) : '';\n      seperator = defaultString || descriptionString || exampleString ? \"\\n\" + repeatString$('=', pre.length) : '';\n      return pre + \"\" + seperator + defaultString + descriptionString + exampleString;\n    };\n  };\n  generateHelp = function(arg$){\n    var options, prepend, append, helpStyle, ref$, stdout, aliasSeparator, typeSeparator, descriptionSeparator, maxPadFactor, initialIndent, secondaryIndent;\n    options = arg$.options, prepend = arg$.prepend, append = arg$.append, helpStyle = (ref$ = arg$.helpStyle) != null\n      ? ref$\n      : {}, stdout = arg$.stdout;\n    setHelpStyleDefaults(helpStyle);\n    aliasSeparator = helpStyle.aliasSeparator, typeSeparator = helpStyle.typeSeparator, descriptionSeparator = helpStyle.descriptionSeparator, maxPadFactor = helpStyle.maxPadFactor, initialIndent = helpStyle.initialIndent, secondaryIndent = helpStyle.secondaryIndent;\n    return function(arg$){\n      var ref$, showHidden, interpolate, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, len$, item, that, pre, descParts, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen, totalLen, initialSpace, wrapAllFull, i, wrap;\n      ref$ = arg$ != null\n        ? arg$\n        : {}, showHidden = ref$.showHidden, interpolate = ref$.interpolate;\n      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;\n      output = [];\n      out = function(it){\n        return output.push(it != null ? it : '');\n      };\n      if (prepend) {\n        out(interpolate ? interp(prepend, interpolate) : prepend);\n        out();\n      }\n      data = [];\n      optionCount = 0;\n      totalPreLen = 0;\n      preLens = [];\n      for (i$ = 0, len$ = (ref$ = options).length; i$ < len$; ++i$) {\n        item = ref$[i$];\n        if (showHidden || !item.hidden) {\n          if (that = item.heading) {\n            data.push({\n              type: 'heading',\n              value: that\n            });\n          } else {\n            pre = getPreText(item, helpStyle, maxWidth);\n            descParts = [];\n            if ((that = item.description) != null) {\n              descParts.push(that);\n            }\n            if (that = item['enum']) {\n              descParts.push(\"either: \" + naturalJoin(that));\n            }\n            if (item['default'] && !item.negateName) {\n              descParts.push(\"default: \" + item['default']);\n            }\n            desc = descParts.join(' - ');\n            data.push({\n              type: 'option',\n              pre: pre,\n              desc: desc,\n              descLen: desc.length\n            });\n            preLen = pre.length;\n            optionCount++;\n            totalPreLen += preLen;\n            preLens.push(preLen);\n          }\n        }\n      }\n      sortedPreLens = sort(preLens);\n      maxPreLen = sortedPreLens[sortedPreLens.length - 1];\n      preLenMean = initialIndent + totalPreLen / optionCount;\n      x = optionCount > 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;\n      for (i$ = sortedPreLens.length - 1; i$ >= 0; --i$) {\n        preLen = sortedPreLens[i$];\n        if (preLen <= x) {\n          padAmount = preLen;\n          break;\n        }\n      }\n      descSepLen = descriptionSeparator.length;\n      if (maxWidth != null) {\n        fullWrapCount = 0;\n        partialWrapCount = 0;\n        for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {\n          item = data[i$];\n          if (item.type === 'option') {\n            pre = item.pre, desc = item.desc, descLen = item.descLen;\n            if (descLen === 0) {\n              item.wrap = 'none';\n            } else {\n              preLen = max(padAmount, pre.length) + initialIndent + descSepLen;\n              totalLen = preLen + descLen;\n              if (totalLen > maxWidth) {\n                if (descLen / 2.5 > maxWidth - preLen) {\n                  fullWrapCount++;\n                  item.wrap = 'full';\n                } else {\n                  partialWrapCount++;\n                  item.wrap = 'partial';\n                }\n              } else {\n                item.wrap = 'none';\n              }\n            }\n          }\n        }\n      }\n      initialSpace = repeatString$(' ', initialIndent);\n      wrapAllFull = optionCount > 1 && fullWrapCount + partialWrapCount * 0.5 > optionCount * 0.5;\n      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {\n        i = i$;\n        item = data[i$];\n        if (item.type === 'heading') {\n          if (i !== 0) {\n            out();\n          }\n          out(item.value + \":\");\n        } else {\n          pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;\n          if (maxWidth != null) {\n            if (wrapAllFull || wrap === 'full') {\n              wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);\n              out(initialSpace + \"\" + pre + \"\\n\" + wrap(desc));\n              continue;\n            } else if (wrap === 'partial') {\n              wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);\n              out(initialSpace + \"\" + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\\s+/, ''));\n              continue;\n            }\n          }\n          if (descLen === 0) {\n            out(initialSpace + \"\" + pre);\n          } else {\n            out(initialSpace + \"\" + pad(pre, padAmount) + descriptionSeparator + desc);\n          }\n        }\n      }\n      if (append) {\n        out();\n        out(interpolate ? interp(append, interpolate) : append);\n      }\n      return unlines(output);\n    };\n  };\n  function pad(str, num){\n    var len, padAmount;\n    len = str.length;\n    padAmount = num - len;\n    return str + \"\" + repeatString$(' ', padAmount > 0 ? padAmount : 0);\n  }\n  function sentencize(str){\n    var first, rest, period;\n    first = str.charAt(0).toUpperCase();\n    rest = str.slice(1);\n    period = /[\\.!\\?]$/.test(str) ? '' : '.';\n    return first + \"\" + rest + period;\n  }\n  function interp(string, object){\n    return string.replace(/{{([a-zA-Z$_][a-zA-Z$_0-9]*)}}/g, function(arg$, key){\n      var ref$;\n      return (ref$ = object[key]) != null\n        ? ref$\n        : \"{{\" + key + \"}}\";\n    });\n  }\n  module.exports = {\n    generateHelp: generateHelp,\n    generateHelpForOption: generateHelpForOption\n  };\n  function repeatString$(str, n){\n    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;\n    return r;\n  }\n}).call(this);\n"]}