{"version":3,"sources":["index.js","dateRange.js","dnsDomainIs.js","dnsDomainLevels.js","dnsResolve.js","isInNet.js","isPlainHostName.js","isResolvable.js","localHostOrDomainIs.js","myIpAddress.js","shExpMatch.js","timeRange.js","weekdayRange.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,ACHA,AJYA;ACFA,ACHA,ACHA,ACHA,AJYA;ACFA,ACHA,ACHA,ACHA,AJYA;ACFA,ACHA,ACHA,ACHA,AJYA,AKfA;AJaA,ACHA,ACHA,ACHA,AJYA,AKfA;AJaA,ACHA,ACHA,ACHA,AJYA,AKfA;AJaA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA;ALgBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA;ALgBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA;ALgBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA;ANmBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA;ANmBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA;ANmBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA;APsBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA;APsBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA;APsBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA;ARyBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA;ARyBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA;ARyBA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA;AT4BA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AV+BA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AV+BA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AV+BA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AENA,ACHA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AKfA,AGTA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA;AXkCA,ADGA,AS3BA,ACHA,ACHA,ACHA;AXkCA,ADGA,AS3BA,ACHA,ACHA,ACHA;AXkCA,ADGA,AS3BA,ACHA,ACHA,ACHA;AXkCA,ADGA,AS3BA,ACHA,ACHA,ACHA;AXkCA,ADGA,AU9BA,ACHA,ACHA;AXkCA,ADGA,AU9BA,ACHA,ACHA;AXkCA,ADGA,AWjCA,ACHA;AXkCA,ADGA,AWjCA,ACHA;AXkCA,ADGA,AWjCA,ACHA;AXkCA,ADGA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA,ACHA;AZqCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AXkCA,AWjCA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/**\n * Module dependencies.\n */\n\nvar co = require('co');\nvar vm = require('vm');\nvar parse = require('url').parse;\nvar thunkify = require('thunkify');\nvar degenerator = require('degenerator');\n\n/**\n * Built-in PAC functions.\n */\n\nvar dateRange = require('./dateRange');\nvar dnsDomainIs = require('./dnsDomainIs');\nvar dnsDomainLevels = require('./dnsDomainLevels');\nvar dnsResolve = require('./dnsResolve');\nvar isInNet = require('./isInNet');\nvar isPlainHostName = require('./isPlainHostName');\nvar isResolvable = require('./isResolvable');\nvar localHostOrDomainIs = require('./localHostOrDomainIs');\nvar myIpAddress = require('./myIpAddress');\nvar shExpMatch = require('./shExpMatch');\nvar timeRange = require('./timeRange');\nvar weekdayRange = require('./weekdayRange');\n\n/**\n * Module exports.\n */\n\nmodule.exports = generate;\n\n/**\n * Returns an asyncronous `FindProxyForURL` function from the\n * given JS string (from a PAC file).\n *\n * @param {String} str JS string\n * @param {Object} opts optional \"options\" object\n * @return {Function} async resolver function\n */\n\nfunction generate (_str, opts) {\n  var i;\n  var str = String(_str)\n\n  // the sandbox to use for the vm\n  var sandbox = {\n    dateRange: dateRange,\n    dnsDomainIs: dnsDomainIs,\n    dnsDomainLevels: dnsDomainLevels,\n    dnsResolve: dnsResolve,\n    isInNet: isInNet,\n    isPlainHostName: isPlainHostName,\n    isResolvable: isResolvable,\n    localHostOrDomainIs: localHostOrDomainIs,\n    myIpAddress: myIpAddress,\n    shExpMatch: shExpMatch,\n    timeRange: timeRange,\n    weekdayRange: weekdayRange\n  };\n\n  // copy the properties from the user-provided `sandbox` onto ours\n  if (opts && opts.sandbox) {\n    for (i in opts.sandbox) {\n      sandbox[i] = opts.sandbox[i];\n    }\n  }\n\n  // construct the array of async function names to add `yield` calls to.\n  // user-provided async functions added to the `sandbox` must have an\n  // `async = true` property set on the function instance\n  var names = [];\n  for (i in sandbox) {\n    if (sandbox[i].async) {\n      names.push(i);\n      sandbox[i] = thunkify(sandbox[i]);\n    }\n  }\n  //console.log(names);\n\n  // convert the JS FindProxyForURL function into a generator function\n  var js = degenerator(str, names);\n\n  // filename of the pac file for the vm\n  var filename = (opts && opts.filename) || 'proxy.pac';\n\n  // evaluate the JS string and extract the FindProxyForURL generator function\n  var fn = vm.runInNewContext(js + ';FindProxyForURL', sandbox, filename);\n  if ('function' != typeof fn) {\n    throw new TypeError('PAC file JavaScript contents must define a `FindProxyForURL` function');\n  }\n\n  // return the async resolver function\n  var resolver = co.wrap(fn);\n\n  return function FindProxyForURL (url, _host, _callback) {\n    let host\n    let callback\n    switch (arguments.length) {\n      case 3:\n        host = _host\n        callback = _callback\n        break;\n      case 2:\n        if (typeof _host === 'function') {\n          callback = _host\n        } else {\n          host = _host\n        }\n        break;\n    }\n\n    if (!host) {\n      host = parse(url).hostname;\n    }\n\n    const promise = resolver(url, host, callback);\n\n    if (typeof callback === 'function') {\n      toCallback(promise, callback)\n    } else {\n      return promise\n    }\n  };\n}\n\nfunction toCallback (promise, callback) {\n  let called = false\n  function resolve(rtn) {\n    if (called) return\n    called = true\n    callback(null, rtn)\n  }\n  function reject(err) {\n    if (called) return\n    called = true\n    callback(err)\n  }\n  promise.then(resolve, reject)\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = dateRange;\n\n/**\n * If only a single value is specified (from each category: day, month, year), the\n * function returns a true value only on days that match that specification. If\n * both values are specified, the result is true between those times, including\n * bounds.\n *\n * Even though the examples don't show, the \"GMT\" parameter can be specified\n * in any of the 9 different call profiles, always as the last parameter.\n *\n * Examples:\n *\n * ``` js\n * dateRange(1)\n * true on the first day of each month, local timezone.\n *\n * dateRange(1, \"GMT\")\n * true on the first day of each month, GMT timezone.\n *\n * dateRange(1, 15)\n * true on the first half of each month.\n *\n * dateRange(24, \"DEC\")\n * true on 24th of December each year.\n *\n * dateRange(24, \"DEC\", 1995)\n * true on 24th of December, 1995.\n *\n * dateRange(\"JAN\", \"MAR\")\n * true on the first quarter of the year.\n *\n * dateRange(1, \"JUN\", 15, \"AUG\")\n * true from June 1st until August 15th, each year (including June 1st and August\n * 15th).\n *\n * dateRange(1, \"JUN\", 15, 1995, \"AUG\", 1995)\n * true from June 1st, 1995, until August 15th, same year.\n *\n * dateRange(\"OCT\", 1995, \"MAR\", 1996)\n * true from October 1995 until March 1996 (including the entire month of October\n * 1995 and March 1996).\n *\n * dateRange(1995)\n * true during the entire year 1995.\n *\n * dateRange(1995, 1997)\n * true from beginning of year 1995 until the end of year 1997.\n * ```\n *\n * dateRange(day)\n * dateRange(day1, day2)\n * dateRange(mon)\n * dateRange(month1, month2)\n * dateRange(year)\n * dateRange(year1, year2)\n * dateRange(day1, month1, day2, month2)\n * dateRange(month1, year1, month2, year2)\n * dateRange(day1, month1, year1, day2, month2, year2)\n * dateRange(day1, month1, year1, day2, month2, year2, gmt)\n *\n * @param {String} day is the day of month between 1 and 31 (as an integer).\n * @param {String} month is one of the month strings: JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC\n * @param {String} year is the full year number, for example 1995 (but not 95). Integer.\n * @param {String} gmt is either the string \"GMT\", which makes time comparison occur in GMT timezone; if left unspecified, times are taken to be in the local timezone.\n * @return {Boolean}\n */\n\nfunction dateRange () {\n  // TODO: implement me!\n  return false;\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = dnsDomainIs;\n\n/**\n * Returns true iff the domain of hostname matches.\n *\n * Examples:\n *\n * ``` js\n * dnsDomainIs(\"www.netscape.com\", \".netscape.com\")\n *   // is true.\n *\n * dnsDomainIs(\"www\", \".netscape.com\")\n *   // is false.\n *\n * dnsDomainIs(\"www.mcom.com\", \".netscape.com\")\n *   // is false.\n * ```\n *\n *\n * @param {String} host is the hostname from the URL.\n * @param {String} domain is the domain name to test the hostname against.\n * @return {Boolean} true iff the domain of the hostname matches.\n */\n\nfunction dnsDomainIs (host, domain) {\n  host = String(host);\n  domain = String(domain);\n  return host.substr(domain.length * -1) === domain;\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = dnsDomainLevels;\n\n/**\n * Returns the number (integer) of DNS domain levels (number of dots) in the\n * hostname.\n *\n * Examples:\n *\n * ``` js\n * dnsDomainLevels(\"www\")\n *   // returns 0.\n * dnsDomainLevels(\"www.netscape.com\")\n *   // returns 2.\n * ```\n *\n * @param {String} host is the hostname from the URL.\n * @return {Number} number of domain levels\n */\n\nfunction dnsDomainLevels (host) {\n  var match = String(host).match(/\\./g);\n  var levels = 0;\n  if (match) {\n    levels = match.length;\n  }\n  return levels;\n}\n","\n/**\n * Module dependencies.\n */\n\nvar dns = require('dns');\n\n/**\n * Module exports.\n */\n\nmodule.exports = dnsResolve;\n\ndnsResolve.async = true;\n\n/**\n * Resolves the given DNS hostname into an IP address, and returns it in the dot\n * separated format as a string.\n *\n * Example:\n *\n * ``` js\n * dnsResolve(\"home.netscape.com\")\n *   // returns the string \"198.95.249.79\".\n * ```\n *\n * @param {String} host hostname to resolve\n * @return {String} resolved IP address\n */\n\nfunction dnsResolve (host, fn) {\n  var family = 4;\n  dns.lookup(host, family, function (err, ip) {\n    if (err) return fn(err);\n    fn(null, ip || '127.0.0.1');\n  });\n}\n","\n/**\n * Module dependencies.\n */\n\nvar dns = require('dns');\nvar Netmask = require('netmask').Netmask;\n\n/**\n * Module exports.\n */\n\nmodule.exports = isInNet;\n\nisInNet.async = true;\n\n/**\n * True iff the IP address of the host matches the specified IP address pattern.\n *\n * Pattern and mask specification is done the same way as for SOCKS configuration.\n *\n * Examples:\n *\n * ``` js\n * isInNet(host, \"198.95.249.79\", \"255.255.255.255\")\n *   // is true iff the IP address of host matches exactly 198.95.249.79.\n *\n * isInNet(host, \"198.95.0.0\", \"255.255.0.0\")\n *   // is true iff the IP address of the host matches 198.95.*.*.\n * ```\n *\n * @param {String} host a DNS hostname, or IP address. If a hostname is passed,\n *   it will be resoved into an IP address by this function.\n * @param {String} pattern an IP address pattern in the dot-separated format mask.\n * @param {String} mask for the IP address pattern informing which parts of the\n *   IP address should be matched against. 0 means ignore, 255 means match.\n * @return {Boolean}\n */\n\nfunction isInNet (host, pattern, mask, fn) {\n  var family = 4;\n  dns.lookup(host, family, function (err, ip) {\n    if (err) return fn(err);\n    if (!ip) ip = '127.0.0.1';\n    var netmask = new Netmask(pattern, mask);\n    fn(null, netmask.contains(ip));\n  });\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = isPlainHostName;\n\n/**\n * True iff there is no domain name in the hostname (no dots).\n *\n * Examples:\n *\n * ``` js\n * isPlainHostName(\"www\")\n *   // is true.\n *\n * isPlainHostName(\"www.netscape.com\")\n *   // is false.\n * ```\n *\n * @param {String} host The hostname from the URL (excluding port number).\n * @return {Boolean}\n */\n\nfunction isPlainHostName (host) {\n  return !(/\\./.test(host));\n}\n","\n/**\n * Module dependencies.\n */\n\nvar dns = require('dns');\n\n/**\n * Module exports.\n */\n\nmodule.exports = isResolvable;\n\nisResolvable.async = true;\n\n/**\n * Tries to resolve the hostname. Returns true if succeeds.\n *\n * @param {String} host is the hostname from the URL.\n * @return {Boolean}\n */\n\nfunction isResolvable (host, fn) {\n  var family = 4;\n  dns.lookup(host, family, function (err, ip) {\n    fn(null, !err);\n  });\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = localHostOrDomainIs;\n\n/**\n * Is true if the hostname matches exactly the specified hostname, or if there is\n * no domain name part in the hostname, but the unqualified hostname matches.\n *\n * Examples:\n *\n * ``` js\n * localHostOrDomainIs(\"www.netscape.com\", \"www.netscape.com\")\n *   // is true (exact match).\n *\n * localHostOrDomainIs(\"www\", \"www.netscape.com\")\n *   // is true (hostname match, domain not specified).\n *\n * localHostOrDomainIs(\"www.mcom.com\", \"www.netscape.com\")\n *   // is false (domain name mismatch).\n *\n * localHostOrDomainIs(\"home.netscape.com\", \"www.netscape.com\")\n *   // is false (hostname mismatch).\n * ```\n *\n * @param {String} host the hostname from the URL.\n * @param {String} hostdom fully qualified hostname to match against.\n * @return {Boolean}\n */\n\nfunction localHostOrDomainIs (host, hostdom) {\n  var parts = String(host).split('.');\n  var domparts = String(hostdom).split('.');\n  var matches = true;\n\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i] !== domparts[i]) {\n      matches = false;\n      break;\n    }\n  }\n\n  return matches;\n}\n","\n/**\n * Module dependencies.\n */\n\nvar net = require('net');\nvar ip = require('ip');\n\n/**\n * Module exports.\n */\n\nmodule.exports = myIpAddress;\n\nmyIpAddress.async = true;\n\n/**\n * Returns the IP address of the host that the Navigator is running on, as\n * a string in the dot-separated integer format.\n *\n * Example:\n *\n * ``` js\n * myIpAddress()\n *   // would return the string \"198.95.249.79\" if you were running the\n *   // Navigator on that host.\n * ```\n *\n * @return {String} external IP address\n */\n\nfunction myIpAddress (fn) {\n  // 8.8.8.8:53 is \"Google Public DNS\":\n  // https://developers.google.com/speed/public-dns/\n  var socket = net.connect({ host: '8.8.8.8', port: 53 });\n  socket.once('error', function(err) {\n    // if we fail to access Google DNS (as in firewall blocks access), \n    // fallback to querying IP locally\n    fn(null, ip.address());\n  });\n  socket.once('connect', function () {\n    socket.removeListener('error', fn);\n    var ip = socket.address().address;\n    socket.destroy();\n    fn(null, ip);\n  });\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = shExpMatch;\n\n/**\n * Returns true if the string matches the specified shell\n * expression.\n *\n * Actually, currently the patterns are shell expressions,\n * not regular expressions.\n *\n * Examples:\n *\n * ``` js\n * shExpMatch(\"http://home.netscape.com/people/ari/index.html\", \"*\\/ari/*\")\n *   // is true.\n *\n * shExpMatch(\"http://home.netscape.com/people/montulli/index.html\", \"*\\/ari/*\")\n *   // is false.\n * ```\n *\n * @param {String} str is any string to compare (e.g. the URL, or the hostname).\n * @param {String} shexp is a shell expression to compare against.\n * @return {Boolean} true if the string matches the shell expression.\n */\n\nfunction shExpMatch (str, shexp) {\n  var re = toRegExp(shexp);\n  return re.test(str);\n}\n\n/**\n * Converts a \"shell expression\" to a JavaScript RegExp.\n *\n * @api private\n */\n\nfunction toRegExp (str) {\n  str = String(str)\n    .replace(/\\?/g, '.')\n    .replace(/\\*/g, '(.*)');\n  return new RegExp('^' + str + '$');\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = timeRange;\n\n/**\n * True during (or between) the specified time(s).\n *\n * Even though the examples don't show it, this parameter may be present in\n * each of the different parameter profiles, always as the last parameter.\n *\n *\n * Examples:\n *\n * ``` js\n * timerange(12)\n * true from noon to 1pm.\n *\n * timerange(12, 13)\n * same as above.\n *\n * timerange(12, \"GMT\")\n * true from noon to 1pm, in GMT timezone.\n *\n * timerange(9, 17)\n * true from 9am to 5pm.\n *\n * timerange(8, 30, 17, 00)\n * true from 8:30am to 5:00pm.\n *\n * timerange(0, 0, 0, 0, 0, 30)\n * true between midnight and 30 seconds past midnight.\n * ```\n *\n * timeRange(hour)\n * timeRange(hour1, hour2)\n * timeRange(hour1, min1, hour2, min2)\n * timeRange(hour1, min1, sec1, hour2, min2, sec2)\n * timeRange(hour1, min1, sec1, hour2, min2, sec2, gmt)\n *\n * @param {String} hour is the hour from 0 to 23. (0 is midnight, 23 is 11 pm.)\n * @param {String} min minutes from 0 to 59.\n * @param {String} sec seconds from 0 to 59.\n * @param {String} gmt either the string \"GMT\" for GMT timezone, or not specified, for local timezone.\n * @return {Boolean}\n */\n\nfunction timeRange () {\n  var args        = Array.prototype.slice.call(arguments),\n      lastArg     = args.pop(),\n      useGMTzone  = (lastArg == \"GMT\"),\n      currentDate = new Date();\n\n  if (!useGMTzone) { args.push(lastArg); }\n\n  var noOfArgs    = args.length,\n      result      = false,\n      numericArgs = args.map(function(n) { return parseInt(n) });\n\n  // timeRange(hour)\n  if (noOfArgs == 1) {\n    result = getCurrentHour(useGMTzone, currentDate) == numericArgs[0];\n\n  // timeRange(hour1, hour2)\n  } else if (noOfArgs == 2) {\n    var currentHour = getCurrentHour(useGMTzone, currentDate);\n    result = (numericArgs[0] <= currentHour) && (currentHour < numericArgs[1]);\n\n  // timeRange(hour1, min1, hour2, min2)\n  } else if (noOfArgs == 4) {\n    result =\n      valueInRange(\n        secondsElapsedToday(numericArgs[0], numericArgs[1], 0),\n        secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), 0),\n        secondsElapsedToday(numericArgs[2], numericArgs[3], 59)\n      );\n\n  // timeRange(hour1, min1, sec1, hour2, min2, sec2)\n  } else if (noOfArgs == 6) {\n    result =\n      valueInRange(\n        secondsElapsedToday(numericArgs[0], numericArgs[1], numericArgs[2]),\n        secondsElapsedToday(\n          getCurrentHour(useGMTzone, currentDate),\n          getCurrentMinute(useGMTzone, currentDate),\n          getCurrentSecond(useGMTzone, currentDate)\n        ),\n        secondsElapsedToday(numericArgs[3], numericArgs[4], numericArgs[5])\n      );\n  }\n\n  return result;\n}\n\nfunction secondsElapsedToday (hh, mm, ss) {\n  return ((hh*3600) + (mm*60) + ss);\n}\n\nfunction getCurrentHour (gmt, currentDate) {\n  return (gmt ? currentDate.getUTCHours() : currentDate.getHours());\n}\n\nfunction getCurrentMinute (gmt, currentDate) {\n  return (gmt ? currentDate.getUTCMinutes() : currentDate.getMinutes());\n}\n\nfunction getCurrentSecond (gmt, currentDate) {\n  return (gmt ? currentDate.getUTCSeconds() : currentDate.getSeconds());\n}\n\n// start <= value <= finish\nfunction valueInRange (start, value, finish) {\n  return (start <= value) && (value <= finish);\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = weekdayRange;\n\n/**\n * Only the first parameter is mandatory. Either the second, the third, or both\n * may be left out.\n *\n * If only one parameter is present, the function yeilds a true value on the\n * weekday that the parameter represents. If the string \"GMT\" is specified as\n * a second parameter, times are taken to be in GMT, otherwise in local timezone.\n *\n * If both wd1 and wd1 are defined, the condition is true if the current weekday\n * is in between those two weekdays. Bounds are inclusive. If the \"GMT\" parameter\n * is specified, times are taken to be in GMT, otherwise the local timezone is\n * used.\n *\n * Valid \"weekday strings\" are:\n *\n *     SUN MON TUE WED THU FRI SAT\n *\n * Examples:\n *\n * ``` js\n * weekdayRange(\"MON\", \"FRI\")\n * true Monday trhough Friday (local timezone).\n *\n * weekdayRange(\"MON\", \"FRI\", \"GMT\")\n * same as above, but GMT timezone.\n *\n * weekdayRange(\"SAT\")\n * true on Saturdays local time.\n *\n * weekdayRange(\"SAT\", \"GMT\")\n * true on Saturdays GMT time.\n *\n * weekdayRange(\"FRI\", \"MON\")\n * true Friday through Monday (note, order does matter!).\n * ```\n *\n * \n * @param {String} wd1 one of the weekday strings.\n * @param {String} wd2 one of the weekday strings.\n * @param {String} gmt is either the string: GMT or is left out.\n * @return {Boolean}\n */\n\nconst dayOrder = { \"SUN\": 0, \"MON\": 1, \"TUE\": 2, \"WED\": 3, \"THU\": 4, \"FRI\": 5, \"SAT\": 6 };\n\nfunction weekdayRange (wd1, wd2, gmt) {\n\n  var useGMTzone = (wd2 == \"GMT\" || gmt == \"GMT\"),\n      todaysDay  = getTodaysDay(useGMTzone),\n      wd1Index   = dayOrder[wd1] || -1,\n      wd2Index   = dayOrder[wd2] || -1,\n      result     = false;\n\n  if (wd2Index < 0) {\n    result = (todaysDay == wd1Index);\n  } else {\n    if (wd1Index <= wd2Index) {\n      result = valueInRange(wd1Index, todaysDay, wd2Index);\n    } else {\n      result = valueInRange(wd1Index, todaysDay, 6) || valueInRange(0, todaysDay, wd2Index);\n    }\n  }\n  return result;\n}\n\nfunction getTodaysDay (gmt) {\n  return (gmt ? (new Date()).getUTCDay() : (new Date()).getDay());\n}\n\n// start <= value <= finish\nfunction valueInRange (start, value, finish) {\n  return (start <= value) && (value <= finish);\n}\n"]}