Vue2.x
-

- 基础认识
    1. 什么是Vue

       > Vue是什么:Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统

    2. 如何让Vue工作
        1. > 必须创建一个Vue的配置对象
        2. > 在html页面中创建和Vue的连接的模板，这里的代码也称为Vue模板
        3. > Vue中的实例和容器中的是一一对应的

- 文本插值

  > 在Vue中，一切的东西都是响应式的，不再和HTML直接进行交互，而是通过Vue来对“字符串模板”进行响应

    1. 插值语法：

       > 功能：用于解析标签体内容。
       >
       >   写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。

    2. 指令语法：

       > 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。
       >
       >   举例：v-bind:href="xxx" 或 简写为 :href="xxx"，xxx同样要写js表达式，
       >
       >   注：Vue中的所有指令都带有“V-”用于进行区分

- 数据绑定

    1. 单向绑定：

       > 单向的数据数据绑定只有开始时响应的数据对页面的内容进行影响，但是当页面的值再进行更改时，不会影响到原先响应时的数据
       >
       >   Vue中的 v-bind: 就是完成的单向数据绑定【对以后页面中数据的修改，后端不会仅监控】

    2. 双向数据绑定：

       > 双向数据绑定不仅仅能同后台将数据交给HTML，当HTML修改数据时，也能在后台进行响应
       >
       >   Vue中的 v-model 就是完成的双向绑定
       >
       >   但不是所有元素都支持绑定 v-model属性，这个属性只支持表单元素（拥有value值的元素才能使用）
       >
       >   简写：v-model:value="属性名" ——> v-model="属性名“

- Vue中的el和data的两种写法【这两种写法都依赖与Vue的方法，所以不能使用箭头函数，使用时无法确认this】

    1. 第一种：都可以按照指定的格式进行书写，在新建的Vue模板中进行数据的新建和传入

       ```js
           let vm = new Vue({
               el: '要绑定的元素',
               data: {
                   属性名：”属性值“
               },
           })
       ```

    2. 第二种：

        1. 对于el：新建的Vue的原型中提供了：Vue实例.$mount("元素或元素选择器")，可以通过这个直接对元素进行选择，和第一种方式没有差异，二者完全相同，当获取到指定元素数据的改变时，会自动在页面进行渲染

        2. 对于data：可以创建一个方法，方法的返回值必须是一个对象，

           ```js
           data: function () {
                       return {
                           属性名: 属性值,
                       }
                   }
           ```

           这种可以简写为：

           ```js
           data () {
                       return {
                           name: 'Jack',
                       }
                   }
           ```

- Vue中的MVVM模型：

  > MVVM模型：
  >      M：模型（model）【对应data中的数据】
  >      V：视图（View）【模板】
  >      VM：视图模型（ViewModel）【vue实例对象】
  >
  >   MVVM模型对应到Vue就像是
  >   M就是数据，在这里存在各种数据，但是不会出现在HTMl中
  >   V就是HTML，这里只是一个模板和结构，不会出现任何的数据，和后端没有任何关联
  >   VM就是Vue，通过Vue将前后两端通过Vue进行了关联，二者得到了连接

- Vue中的数据代理：

    1. Object.defineProperty（）【ES6的新属性】

       > 通过这个方法可以向一个对象中添加新的字段和配置，参数（指定对象，添加的字段，字段的配置】
       >
       >   通过enumerable:true 可以将属性设置成可被遍历的（默认不能遍历
       >   通过writable:true 可以设置内容是可修改的（默认不可
       >   通过configurable:true 可以设置是否可删除（默认不可
       >
       >   数据代理：通过一个对象代理另一个对象中属性的读和写
       >
       >   通过getter和setter方法可以监视指定内容的改变和读取

    2. Vue中的数据代理：

       > 1.Vue中的数据代理：
       >            通过vm对象来代理data对象中属性的操作（读/写）
       >   2.Vue中数据代理的好处：
       >            更加方便的操作data中的数据
       >   3.基本原理：
       >            通过Object.defineProperty()把data对象中所有属性添加到vm上。
       >            为每一个添加到vm上的属性，都指定一个getter/setter。
       >            在getter/setter内部去操作（读/写）data中对应的属性。
       >
       >   在Vue中data的数据保存在vm的_data中
       >   如果将data中的对象定义在外部，定义为data，将data为Vue的data进行赋值，这是完成了
       >
       >   ```js
          >    vm.data = options.data = data 
          >   ```
       >
       >
       >
       >   【option.data表示的是整个new出来的Vue的配置称之为options】
       >
       >   在options中创建的数据会被Vue进行整合，将data中的数据直接通过等于号赋值给_data，但是为了方便起见，当Vue拿到数据时，会添加一个新的属性，就是data中的key，并通过getter读取_data的属性，如果发生改变则使用setter进行更改

- 事件的基本使用

    1. 在Vue中可以在HTML页面使用进行绑定【当要传入多个数据并要使用event时，使用$event进行占位】

       ```html
       1、完整形式
           <button type="button" v-on:click="show">按钮</button>
       2、简写形式
           <button type="button" @click="show">按钮</button>
       3、传参形式
           <button type="button" @click="show2(变量1,变量2,$event)">按钮3</button>
       ```

       并在定义的Vue中使用methods进行事件的绑定

       ```js
       methods: {
                   事件1 (event) {
                       console.log(this)
                       console.log(event)
                   },
                   事件2 (num1, num2,event) {
                       console.log(num1 + num2)
                       console.log(event);
                   },
               },
       ```

       这里的this默认是VM，并且不能使用箭头函数，因为箭头函数没有自己的this会像外查找，会找到window，而当this改变成window反倒是我们不希望的，所以这里不能使用箭头函数

    2. Vue中的事件修饰符

       > Vue中的事件修饰符：
       >      1.prevent：阻止默认事件（常用）；
       >      2.stop：阻止事件冒泡（常用）；
       >      3.once：事件只触发一次（常用）；
       >      4.capture：使用事件的捕获模式；
       >         事件的触发分为捕获阶段和触发阶段，
       >            捕获阶段：当多层的子元素触发了事件，会先进行捕获，将捕获途中遇到的元素都进行记录（所以遇到同类型事件也会进行冒泡触发）
       >            触发阶段：当事件发生并且捕获完毕，那么会开始触发阶段，子元素到父元素由内到外依次触发，同类型事件都会被触发
       >         捕获模式：
       >            让事件在捕获阶段就进行触发
       >
       >      5.self：只有event.target是当前操作的元素时才触发事件；
       >         使用这个也能完成阻止冒泡
       >
       >      6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；
       >
       >     事件完成所有回调才能触发默认事件：
       >        如：滚轮中的 wheel 事件（当鼠标发生滚动事件就进行触发）【这个事件会先进行回调中的内容，然后再触发默认的滚动事件】
       >     事件先触发默认事件再完成回调中的内容：
       >        如：scroll事件会先执行默认的滚动操作，才会进行回调的执行

- Vue中键盘事件

  > Vue中将常用一些按键，如：enter、ctrl等按键都做了简写的配置，可以通过属性直接进行调用并配置
  >
  >   1.Vue中常用的按键别名：
  >            回车 => enter
  >            删除 => delete (捕获“删除”和“退格”键)
  >            退出 => esc
  >            空格 => space
  >            换行 => tab (特殊，必须配合keydown去使用)
  >            上 => up
  >            下 => down
  >            左 => left
  >            右 => right
  >
  >   2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）
  >
  >   ```htm
    >   <input type="text" name="" placeholder="大小写转换键" @keydown.caps-lock="keyup">
    >   ```
  >
  >   3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
  >            (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
  >            (2).配合keydown使用：正常触发事件。
  >
  >   ​ 【在表单操作中tab键会自动转换焦点，如果绑定的事件是keyup那么当指定时，会先转换焦点在进行这个事件，但是这时焦点已经转换，也就不能完成正常操作了，所以可以使用KeyDown进行事件的绑定】
  >
  >   4.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名
  >
  >   ```js
    >   Vue.config.keyCodes.me = 13【指定第13号按键的名字是：me（enter键）】
    >   ```

- 计算属性

  > 计算属性：
  >         1.定义：要用的属性不存在，要通过已有属性计算得来。
  >         2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。
  >         3.get函数什么时候执行？
  >                  (1).初次读取时会执行一次。
  >                  (2).当依赖的数据发生改变时会被再次调用。
  >         4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。
  >         5.备注：
  >               1.计算属性最终会出现在vm上，直接读取使用即可。
  >               2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。
  >
  >   计算属性可以理解成一个方法，这个方法返回的是一个属性，方法中可以进行一些复杂的操作，可以在更加复杂的业务中胜任
  >
  >   计算属性相对与事件的返回值的调用来说效率更高
  >        因为事件的返回值调用，是每一次调用都会进行方法的执行，而计算属性就像是一个值一样，通过第一次 计算后，以后有属性调用直接进行赋值，而不是进行调用原来的方法
  >
  >   完整语法：
  >
  >   ```js
    >   computed: {
    >   	要计算的变量:{
    >   			 	// 只要有人读取了要计算的变量时，get就会被调用且返回值作为计算变量的值
    >   		get(){
    >   			return this.指定变量 + this.指定变量
    >   		},
    >   		set(value){
    >   			this.指定变量 = "指定变量值"
    >   			this.指定变量 = '指定变量值'
    >   		}
    >   	}
    >   }
    >   ```
  >
  >   简洁写法：【仅限这个属性只是用于读取作用时】
  >
  >   ```js
    >   computed: {
    >   	要计算的变量 () {
    >   		return this.指定属性 + this.指定属性
    >   	},
    >   },
    >   ```

- 监视属性

  > 监视属性watch：
  >   1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作
  >   2.监视的属性必须存在，才能进行监视！！
  >   3.监视的两种写法：
  >         (1).new Vue时传入watch配置
  >         (2).通过vm.$watch监视
  >
  >   第一种方式实现：
  >
  >   ```js
    >   watch: {
    >   	isTrue: {
    >   		immediate: true,【让进入这个方法时就调用一次handler】
    >   		handler (新的属性值, 旧的属性值) {
    >   			console.log('我能进行监视的操作')
    >   			console.log(新值, 旧值)
    >    		},
    >    	},
    >   },
    >   ```
  >
  >   第二种方式：
  >
  >   ```js
    >   vm.$watch('isTrue', {
    >   		immediate: true,
    >   		handler (新的属性值, 旧的属性值) {
    >   			console.log('我能进行监视的操作')
    >   			console.log(新值, 旧值)
    >    		},
    >   	})
    >   ```
  >
  >   > 深度监视：
  >   >
  >   >   ​ 当一个数据存在多级数据，如数组或对象中相互嵌套，Vue默认不会进行所有数据的监视【为了保证性能，有一些监视是没有必要的】所以当要使用多层监视可以使用
  >   >
  >   >   ```js	
    >   >   deep: true
    >   >   ```
  >
  >   简写形式：【当一个数据监视只有一个handler方法时，可以使用简写属性】
  >
  >   ```js	
    >   vm.$watch('要监视的内容', function (newValue, oldValue) {
    >   	console.log('这个同样可以进行监视改变')
    >   })
    >   
    >   watch: {
    >   	要监视的属性 (newValue, oldValue) {
    >   		console.log('我也能我完成监视')
    >   	},
    >   },
    >   ```
  >
  >   > 计算属性和监视属性的区别：
  >   >                计算属性是通过获取到实时数据并立马做出反馈，但是不能进行异步的调用，如果使用异步因为不能立马有返回值，所以返回的内容一直是空
  >   >                监视属性是通过配置一个新的属性，这个属性改变的同时会立马在页面进行反应，所以，可以使用异步任务进行调用
  >   >
  >   >   computed和watch之间的区别：
  >   >      1.computed能完成的功能，watch都可以完成。
  >   >      2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。
  >   >
  >   >   两个重要的小原则：
  >   >      1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。
  >   >      2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，
  >   >         这样this的指向才是vm 或 组件实例对象。
  >   >
  >   >   【所有在VM中要定义的异步方法或默认是this是window的函数都要使用箭头函数，保证能调用到的this都是VM】

- 
