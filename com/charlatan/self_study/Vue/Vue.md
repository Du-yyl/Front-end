Vue2.x
-

- 基础认识
    1. 什么是Vue

       > Vue是什么:Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统

    2. 如何让Vue工作
        1. > 必须创建一个Vue的配置对象
        2. > 在html页面中创建和Vue的连接的模板，这里的代码也称为Vue模板
        3. > Vue中的实例和容器中的是一一对应的

- 文本插值

  > 在Vue中，一切的东西都是响应式的，不再和HTML直接进行交互，而是通过Vue来对“字符串模板”进行响应

    1. 插值语法：

       > 功能：用于解析标签体内容。
       >
       >   写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。

    2. 指令语法：

       > 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。
       >
       >   举例：v-bind:href="xxx" 或 简写为 :href="xxx"，xxx同样要写js表达式，
       >
       >   注：Vue中的所有指令都带有“V-”用于进行区分

- 数据绑定

    1. 单向绑定：

       > 单向的数据数据绑定只有开始时响应的数据对页面的内容进行影响，但是当页面的值再进行更改时，不会影响到原先响应时的数据
       >
       >   Vue中的 v-bind: 就是完成的单向数据绑定【对以后页面中数据的修改，后端不会仅监控】

    2. 双向数据绑定：

       > 双向数据绑定不仅仅能同后台将数据交给HTML，当HTML修改数据时，也能在后台进行响应
       >
       >   Vue中的 v-model 就是完成的双向绑定
       >
       >   但不是所有元素都支持绑定 v-model属性，这个属性只支持表单元素（拥有value值的元素才能使用）
       >
       >   简写：v-model:value="属性名" ——> v-model="属性名“

- Vue中的el和data的两种写法【这两种写法都依赖与Vue的方法，所以不能使用箭头函数，使用时无法确认this】

    1. 第一种：都可以按照指定的格式进行书写，在新建的Vue模板中进行数据的新建和传入

       ```js
           let vm = new Vue({
               el: '要绑定的元素',
               data: {
                   属性名:"属性值"
               },
           })
       ```

    2. 第二种：

        1. 对于el：新建的Vue的原型中提供了：Vue实例.$mount("元素或元素选择器")，可以通过这个直接对元素进行选择，和第一种方式没有差异，二者完全相同，当获取到指定元素数据的改变时，会自动在页面进行渲染

        2. 对于data：可以创建一个方法，方法的返回值必须是一个对象，

           ```js
           data: function () {
                       return {
                           属性名: 属性值,
                       }
                   }
           ```

           这种可以简写为：

           ```js
           data () {
                       return {
                           name: 'Jack',
                       }
                   }
           ```

- Vue中的MVVM模型：

  > MVVM模型：
  > M：模型（model）【对应data中的数据】
  > V：视图（View）【模板】
  > VM：视图模型（ViewModel）【vue实例对象】
  >
  >   MVVM模型对应到Vue就像是
  > M就是数据，在这里存在各种数据，但是不会出现在HTMl中
  > V就是HTML，这里只是一个模板和结构，不会出现任何的数据，和后端没有任何关联
  > VM就是Vue，通过Vue将前后两端通过Vue进行了关联，二者得到了连接

- Vue中的数据代理：

    1. Object.defineProperty（）【ES6的新属性】

       > 通过这个方法可以向一个对象中添加新的字段和配置，参数（指定对象，添加的字段，字段的配置】
       >
       >   通过enumerable:true 可以将属性设置成可被遍历的（默认不能遍历
       >   通过writable:true 可以设置内容是可修改的（默认不可
       >   通过configurable:true 可以设置是否可删除（默认不可
       >
       >   数据代理：通过一个对象代理另一个对象中属性的读和写
       >
       >   通过getter和setter方法可以监视指定内容的改变和读取

    2. Vue中的数据代理：

       > 1.Vue中的数据代理：
       >            通过vm对象来代理data对象中属性的操作（读/写）
       >   2.Vue中数据代理的好处：
       >            更加方便的操作data中的数据
       >   3.基本原理：
       >            通过Object.defineProperty()把data对象中所有属性添加到vm上。
       >            为每一个添加到vm上的属性，都指定一个getter/setter。
       >            在getter/setter内部去操作（读/写）data中对应的属性。
       >
       >   在Vue中data的数据保存在vm的_data中
       >   如果将data中的对象定义在外部，定义为data，将data为Vue的data进行赋值，这是完成了
       >
       >   ```js
          >    vm.data = options.data = data 
          >   ```
       >
       >
       >
       >   【option.data表示的是整个new出来的Vue的配置称之为options】
       >
       >   在options中创建的数据会被Vue进行整合，将data中的数据直接通过等于号赋值给_data，但是为了方便起见，当Vue拿到数据时，会添加一个新的属性，就是data中的key，并通过getter读取_data的属性，如果发生改变则使用setter进行更改

- 事件的基本使用

    1. 在Vue中可以在HTML页面使用进行绑定【当要传入多个数据并要使用event时，使用$event进行占位】

       ```html
       1、完整形式
           <button type="button" v-on:click="show">按钮</button>
       2、简写形式
           <button type="button" @click="show">按钮</button>
       3、传参形式
           <button type="button" @click="show2(变量1,变量2,$event)">按钮3</button>
       ```

       并在定义的Vue中使用methods进行事件的绑定

       ```js
       methods: {
                   事件1 (event) {
                       console.log(this)
                       console.log(event)
                   },
                   事件2 (num1, num2,event) {
                       console.log(num1 + num2)
                       console.log(event);
                   },
               },
       ```

       这里的this默认是VM，并且不能使用箭头函数，因为箭头函数没有自己的this会像外查找，会找到window，而当this改变成window反倒是我们不希望的，所以这里不能使用箭头函数

    2. Vue中的事件修饰符

       > Vue中的事件修饰符：
       >      1.prevent：阻止默认事件（常用）；
       >      2.stop：阻止事件冒泡（常用）；
       >      3.once：事件只触发一次（常用）；
       >      4.capture：使用事件的捕获模式；
       >         事件的触发分为捕获阶段和触发阶段，
       >            捕获阶段：当多层的子元素触发了事件，会先进行捕获，将捕获途中遇到的元素都进行记录（所以遇到同类型事件也会进行冒泡触发）
       >            触发阶段：当事件发生并且捕获完毕，那么会开始触发阶段，子元素到父元素由内到外依次触发，同类型事件都会被触发
       >         捕获模式：
       >            让事件在捕获阶段就进行触发
       >
       >      5.self：只有event.target是当前操作的元素时才触发事件；
       >         使用这个也能完成阻止冒泡
       >
       >      6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；
       >
       >     事件完成所有回调才能触发默认事件：
       >        如：滚轮中的 wheel 事件（当鼠标发生滚动事件就进行触发）【这个事件会先进行回调中的内容，然后再触发默认的滚动事件】
       >     事件先触发默认事件再完成回调中的内容：
       >        如：scroll事件会先执行默认的滚动操作，才会进行回调的执行

- Vue中键盘事件

  > Vue中将常用一些按键，如：enter、ctrl等按键都做了简写的配置，可以通过属性直接进行调用并配置
  >
  >   1.Vue中常用的按键别名：
  > 回车 => enter
  > 删除 => delete (捕获“删除”和“退格”键)
  > 退出 => esc
  > 空格 => space
  > 换行 => tab (特殊，必须配合keydown去使用)
  > 上 => up
  > 下 => down
  > 左 => left
  > 右 => right
  >
  >   2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）
  >
  >   ```htm
    >   <input type="text" name="" placeholder="大小写转换键" @keydown.caps-lock="keyup">
    >   ```
  >
  >   3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
  > (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
  > (2).配合keydown使用：正常触发事件。
  >
  >    【在表单操作中tab键会自动转换焦点，如果绑定的事件是keyup那么当指定时，会先转换焦点在进行这个事件，但是这时焦点已经转换，也就不能完成正常操作了，所以可以使用KeyDown进行事件的绑定】
  >
  >   4.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名
  >
  >   ```js
    >   Vue.config.keyCodes.me = 13【指定第13号按键的名字是：me（enter键）】
    >   ```

- 计算属性

  > 计算属性：
  > 1.定义：要用的属性不存在，要通过已有属性计算得来。
  > 2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。
  > 3.get函数什么时候执行？
  > (1).初次读取时会执行一次。
  > (2).当依赖的数据发生改变时会被再次调用。
  > 4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。
  > 5.备注：
  > 1.计算属性最终会出现在vm上，直接读取使用即可。
  > 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。
  >
  >   计算属性可以理解成一个方法，这个方法返回的是一个属性，方法中可以进行一些复杂的操作，可以在更加复杂的业务中胜任
  >
  >   计算属性相对与事件的返回值的调用来说效率更高
  > 因为事件的返回值调用，是每一次调用都会进行方法的执行，而计算属性就像是一个值一样，通过第一次 计算后，以后有属性调用直接进行赋值，而不是进行调用原来的方法
  >
  >   完整语法：
  >
  >   ```js
    >   computed: {
    >   	要计算的变量:{
    >   			 	// 只要有人读取了要计算的变量时，get就会被调用且返回值作为计算变量的值
    >   		get(){
    >   			return this.指定变量 + this.指定变量
    >   		},
    >   		set(value){
    >   			this.指定变量 = "指定变量值"
    >   			this.指定变量 = '指定变量值'
    >   		}
    >   	}
    >   }
    >   ```
  >
  >   简洁写法：【仅限这个属性只是用于读取作用时】
  >
  >   ```js
    >   computed: {
    >   	要计算的变量 () {
    >   		return this.指定属性 + this.指定属性
    >   	},
    >   },
    >   ```

- 监视属性

  > 监视属性watch：
  > 1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作
  > 2.监视的属性必须存在，才能进行监视！！
  > 3.监视的两种写法：
  > (1).new Vue时传入watch配置
  > (2).通过vm.$watch监视
  >
  >   第一种方式实现：
  >
  >   ```js
    >   watch: {
    >   	isTrue: {
    >   		immediate: true,【让进入这个方法时就调用一次handler】
    >   		handler (新的属性值, 旧的属性值) {
    >   			console.log('我能进行监视的操作')
    >   			console.log(新值, 旧值)
    >    		},
    >    	},
    >   },
    >   ```
  >
  >   第二种方式：
  >
  >   ```js
    >   vm.$watch('isTrue', {
    >   		immediate: true,
    >   		handler (新的属性值, 旧的属性值) {
    >   			console.log('我能进行监视的操作')
    >   			console.log(新值, 旧值)
    >    		},
    >   	})
    >   ```
  >
  >   > 深度监视：
  >   >
  >   >    当一个数据存在多级数据，如数组或对象中相互嵌套，Vue默认不会进行所有数据的监视【为了保证性能，有一些监视是没有必要的】所以当要使用多层监视可以使用
  >   >
  >   >   ```js	
    >   >   deep: true
    >   >   ```
  >
  >   简写形式：【当一个数据监视只有一个handler方法时，可以使用简写属性】
  >
  >   ```js	
    >   vm.$watch('要监视的内容', function (newValue, oldValue) {
    >   	console.log('这个同样可以进行监视改变')
    >   })
    >   
    >   watch: {
    >   	要监视的属性 (newValue, oldValue) {
    >   		console.log('我也能我完成监视')
    >   	},
    >   },
    >   ```
  >
  >   > 计算属性和监视属性的区别：
  > > 计算属性是通过获取到实时数据并立马做出反馈，但是不能进行异步的调用，如果使用异步因为不能立马有返回值，所以返回的内容一直是空
  > > 监视属性是通过配置一个新的属性，这个属性改变的同时会立马在页面进行反应，所以，可以使用异步任务进行调用
  >   >
  >   >   computed和watch之间的区别：
  > > 1.computed能完成的功能，watch都可以完成。
  > > 2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。
  >   >
  >   >   两个重要的小原则：
  > > 1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。
  > > 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，
  > > 这样this的指向才是vm 或 组件实例对象。
  >   >
  >   >   【所有在VM中要定义的异步方法或默认是this是window的函数都要使用箭头函数，保证能调用到的this都是VM】

- 样式绑定

  > 当要在一个元素中添加一些属性如calss时，可以使用Vue提供的方式，使用 v-bind+指定的样式进行绑定，使用Vue的方式更加灵活，所有的元素的内容并不会被固定，可以在后期中进行调整
  >
  >   当要在一个元素中添加class时，可以使用：
  > 正常的样式正常写，变化的样式使用v-bind进行指定，通过’:class‘进行指定，通过Vue可以自动完成一系列操作
  >
  >   1. 当一个元素中的属性个数和内容不确定时：

         >     >                可以将一个div中的多个需要的class直接写在数组中，直接在一个数组中进行指定
  >
      2. 当一个元素中的属性内容确定，个数确定，但是要动态确定用不用的时候：
  >
  >      >                 可以使用对象，直接在对象中使用true和false来指定是否进行显示

      3. 内联样式的操作要使用Vue中指定的v-bind进行指定，指定的内容要在对象中使用键值对的形式进行声明，如果是多个值，可以使用数组进行保管，直接操作数组中的内容
  >      >
  >      >        ```html
  >        使用Vue中的 v-bind:class指定样式名字，可以在后期进行样式的调整后修改
  >        	<div id="div" :class="dem">{{ name }}</div>
  >        当要指定多个属性时，可以使用数组的方法进行指定，能更方便操作
  >        	<div :class="arr">{{ name }}</div>
  >        当指定的属性的个数固定，内容固定，但是要决定属性的使用与否，可以使用对象的形式进行
  >        	<div :class="obj">{{ name }}</div>
  >        当使用内联样式进行操作时，也是使用指定的指令，并将内容写在对象，并通过键值对的方式进行书写或表示
           	<div :style="{fontSize : size + 'px'}">{{ name }}</div>
             ```
         >
         >
    1. class样式
       >                 写法:class="xxx" xxx可以是字符串、对象、数组。
       >                       字符串写法适用于：类名不确定，要动态获取。
       >                       对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。
       >                       数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。
  >        2. style样式
              >                 :style="{fontSize: xxx}"其中xxx是动态值。
              >                 :style="[a,b]"其中a、b是样式对象。

- 条件渲染

  > 当要使一个元素按一定逻辑进行显示与否，可以使用
  >
  >   ```html
    >   v-show = 布尔值
    >   v-if = 布尔值
    >   v-if-else = 布尔值
    >   v-else
    >   ```
  >
  >   指定属性后 可以按照布尔值决定显示与否
  >
  >   v-show 设置元素的display进行显示与否
  >
  >   v-if 系列直接是让一个元素全部消失，全部消失
  >
  >   在一系列的样式中也能通过通过逻辑也能进行逻辑的操作，但是 他们之间不能存在任何其他元素
  >
  >   ```html
    >   	<span v-if="n === 1">第一个</span>
    >   	<span v-else-if="n === 2">第二个</span>
    >   	<span v-else-if="n === 3">第三个</span>
    >   	<span v-else>错误</span>
    >   ```
  >
  >   当要使一段元素都进行展现和消失，可以将这些内容包裹在一个div中，但是包裹div可能会出现其他的问题，如改变了页面结构，而造成一些不必要的更改，可以使用template，他能将内容进行包裹，但是不会影响项目结构【这里必须使用v-if，不能使用v-show】
  >
  >   ```html
    >   	<template v-if="n === 1">
    >   		<span>第一个</span>
    >   		<span>第一个</span>
    >   		<span>第一个</span>
    >   		<span>第一个</span>
    >   	</template>
    >   ```

- 列表渲染

  > 可以使用v-for指令，对数组，对象，字符串进行遍历操作，
  >
  >   v-for指令:
  >        1.用于展示列表数据
  >        2.语法：v-for="(item, index) in xxx" :key="yyy"
  >        3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）
  >
  >   遍历时因为只写一个标签，但是每个标签都是要不同的，所以要使用index进行区分，Vue中的for循环时会有一个自身的内部index，会在底部自增，但是不建议使用这个，而是要要使用每个对象都能区分的独立ID
  >
  >   > 渲染原理：
  >   >
  >   >   1. 当拿到一个指定的标签，并拿到了要进行渲染的数据，这时会按照用户指定的key发生遍历（如果没有使用自身的index）
  >   >
  >   >   2. 先产生一个虚拟DOM，进行对比，如果原网页中没有这些内容，直接转换成真实DOM
  >   >
  >   >   3. 然后将底部进行区分的key删掉，并添加到页面
  >   >
  >   >
  >   >
  >   >   为什么要使用每个对象的key而不能使用底部底部自增的index？
  >   >
  >   >   1. 当要使用Vue中的for循环创建多个标签时，需要在最后传入key的下标，也就是不同的index，【其中index是，vue中循环中自增的，从0开始】
  >   >   2. 如果使用index作为下标：

             >   >
  1. index会从0开始计数，并将现有并提供的数据进行指定index并进行渲染，顺序就是从上到下的顺序。
  > >        2. 如果这时插入数据，（或用其他方式就行数据的打乱），【按照在一个位置进行插入数据】，这时，会从新分配index，
  >   >        3. 这时的新加入的数据就是在第一个位置，他的index会是0，
  >   >        4. 然后，会将原来的第一个的元素和现在第一个的元素进行比较，【这里是按照index进行对比的】，但是index因为顺序问题已经更新，
  >   >        5. 所以，先对比显示的文本内容，发现完全不同，这时进行替换操作，
  >   >        6. 接着，开始对比input框，发现input框的类型和其他属性完全相同（不会对比文本框中的内容，因为如果所有内容相同会直接使用原来的元素，这时也就不用考虑文本的问题，如果不同则表明是一个新的输入框）
  >   >        7. 这时，在新的数据层面，开始的文本元素已经渲染完毕，并且分配了新的index，但是文本框因为所有属性都相同，前面几个内容全部进行了保留，将最后新添加的文本框加在了最后面
  >   >
  >   >   解决问题：
  >   >
  >   >    这个问题出现的原因是因为index的下标重新分配的问题，所以建议在开始时直接对id进行指定，这时如果对比index，那么会直接将ID进行对比，但是每一个数据的ID都是相互独立的，
  > > ​ 这也能解决了这个问题，因为这个新的ID，会和老的ID进行比较，如果相同会直接使用原来的内容，不会重新渲染内容，效率会更高，并且因为ID是指定的并且相互独立，
  > > ​ 添加新元素时，新的序列的第一个元素户会和原来的内容进行对比，这时一定发现的是没有，所以直接进行替换。而剩下的因为渲染过所以直接用原来的真是DOM

- Vue中数据监视的原理

    1. 普通元素数据监视

       > 对于普通数据，Vue会遍历所有的元素和属性，并通过数据代理为属性添加上setter和getter方法，并通过set和get进行监视操作来保证数据的实时渲染

    2. 对象中的数据监视

       > 对象中的所有数据添加监视过程：
       >
       >    会先对所有的对象的属性通过Object.keys()方法，对所有属性进行遍历，并将所有属性添加上setter和getter方法，然后通过setter和getter完成数据劫持
       >
       >   ```js
         >   	let obj = {
         >   		name: 'jock',
         >   		age: 20,
         >   		sex: 'man',
         >   	}
         >   	let vm = {}
         >   	let obs = new Observer(obj)
         >   	vm._data = data = obs
         >   
         >   
         >   	/**
         >   	 * 模拟一个Vue中的数据代理操作，通过获取到属性后，对所有的属性进行遍历，并为每个属性添加上get和set方法
         >   	 * @param obj
         >   	 * @constructor
         >   	 */
         >   	function Observer (obj) {
         >   		let keys = Object.keys(obj)
         >   
         >   		keys.forEach(key => {
         >   
         >   			Object.defineProperty(this, key, {
         >   				get () {
         >   					console.log("被读取");
         >   					return obj[key]
         >   				},
         >   				set (val) {
         >   					console.log("被修改了");
         >   					obj[key] = val
         >   				},
         >   			})
         >   		})
         >   	}
         > ```

    3. 数组中如何实现数据代理

       > Vue为何不能监视数组中的数据的改变：
       >      因为数组中按照下标进行存储，但是对于每个下标Vue没有对应的setter和getter，所以不能进行监视
       >
       >   如何解决：
       >      虽然在底层内容中，的确使指定的内容发生了改变，但是因为Vue并不认可，所以并不会在监视中更新，解决这个可以使用几个对数组的几个操作的方法进行解决
       >      【
       >         push
       >         pop
       >         shift
       >         unshift
       >         splice
       >         sort
       >         reverse
       >      】
       >   只有这几个改变方式能被监视，其他的都不行
       >
       >   这里虽然调用了Array中的方法，但是已经不是原来数组中提供的方法了，因为进行封装

    4. set()的使用

       > 当我们需要在页面打开时，进行动态的添加内容，如果要进行添加数据，只能将属性进行添加，但是不能使用监视属性，再修改时不能动态进行绑定，
       > 为了解决这个问题，可以使用Vue中提供的set进行解决
       >
       >   > Vue.set(vm._data.obj,"per",2000)
       >   >   Vue.set(要操作的属性, 要添加的属性, 添加的属性)
       >
       >   > vm>$set(要操作的属性, 要添加的属性, 添加的属性)
       >
       >   set（）方法的局限性：
       >      不能为：VM和data中不能添加一个响应式数据，只能为data对象中的属性添加内容

- 表单数据的收集

  > 单选框：使用同一个属性，并配置不同的value，当发生改变的时候就会进行转换，并将最新的数据进行更新
  > ​ 复选框：同样配置value，并将内容写到数组中，如果没有value如checkbox会默认收集指定输入框的checked【也就是选项的布尔值】
  > ​ 选择框：使用value进行默认值的选择，当选择出元素时，会将对应的value进行返回
  >
  >   v-model的修饰符
  > .number -> 将输入的内容先进行字符串到数字的转换
  > .lazy -> 设置表单失去焦点再收集数据
  > .trim -> 去除输入的前后空格

- 过滤器

  > 过滤器：
  > 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
  > 语法：
  > 1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}
  > 2.使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = "xxx | 过滤器名"
  > 备注：
  > 1.过滤器也可以接收额外参数、多个过滤器也可以串联
  > 2.并没有改变原本的数据, 是产生新的对应的数据
  >
  >    在Vue中的实例中注册的过滤器都是局部的，如果要注册全局的过滤器，可以在实例化Vue之前就设置指定的过滤器
  >
  >   ```js
    >   	Vue.filter('名字', function () {
    >   		return '返回指定的值'
    >   	})
    >   ```
  >
  >   如果要对过滤器的结果进行操作，可是使用多个管道符进行连接，并通过上一级的返回值传到下一级，来完成操作

- 常见指令

  > 常见指令：
  >
  >   ​ v-bind  : 单向绑定解析表达式, 可简写为 :xxx
  >   ​ v-model    : 双向数据绑定
  >   ​ v-for      : 遍历数组/对象/字符串
  >   ​ v-on       : 绑定事件监听, 可简写为@
  >   ​ v-if      : 条件渲染（动态控制节点是否存存在）
  >   ​ v-else     : 条件渲染（动态控制节点是否存存在）
  >   ​ v-show     : 条件渲染 (动态控制节点是否展示)
  >
  >   v-text:
  >
  >   1. 向指定的元素中渲染文本
  >   2. 与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。
  >   3. v-text不会检测可能存在的代码的编译，会直接进行将指定字符串放在指定位置，并将内容全部替换
  >
  >   v-html:
  >
  >   1. 作用：向指定节点中渲染包含html结构的内容。
  >   2. 与插值语法的区别：
         >           (1).v-html会替换掉节点中所有的内容，{{ xx }}则不会。
         >           (2).v-html可以识别html结构。
  >   3. 严重注意：v-html有安全性问题！！！！
         >           (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。
         >           (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！
  >
  >   v-cloak:
  >
  >   1. 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。
  >   2. 使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。
  >
  >   v-once指令：
  >
  >   1. v-once所在节点在初次动态渲染后，就视为静态内容了。
  >   2. 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。
  >
  >   v-pre指令：
  >
  >   1. 跳过其所在节点的编译过程。
  >   2. 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。
         >        对于在Vue的模板中不需要进行Vue加载的内容，可以使用，可以加快运行速度
  >
  >   自定义指令：
  >
  >   1. 与元素初次绑定时，会先执行一次指令所在的模板被重新编译时，就会调用
  >
  >   2. 完整语法，其中Vue会提供3个时机的运行方法，并通过不同的时机完成不同的操作
         >
         >         ```js
    >         directives: {			
    >         	"自定义指令名": {
    >         		bind (element, binding) {
    >         			console.log('绑定的时候调用')
    >         		},
    >         		inserted (element, binding) {
    >         			console.log('指定元素被插入页面时调用')
    >         		},
    >         		update (element, binding) {
    >         			console.log('指定所在模板重新解析时调用')
    >         		},
    >         	},
    >         },
    >         ```
         >
         >        并且指的注意的是，这些内容中的this都是window，第一个参数是指定内容的真实元素，第二个属性是指定内容绑定内容或其中的属性和value
  >
  >   3. 简写方式：
         >
         >        ```js
    >        directives: {
    >        	big (element, binding) {
    >        		console.log(element, binding.value)
    >        	},
    >        },
    >        ```
         >
         >        这里的简写属性会在绑定的时候进行调用，在指定的模板的data数据更新的时候进行更新，和完成写法的中dind（）和update（）相对应
  >
  >   4. 指的注意的是，这里设置在模板中的内容都是局部的，如果要设置全局的话，要使用全局配置的话同样需要在vue的模板进行配置
         >
         >        ```js
    >        Vue.directive('fbind', {
    >        	//指令与元素成功绑定时（一上来）
    >        	bind (element, binding) {
    >        	},
    >        	//指令所在元素被插入页面时
    >        	inserted (element, binding) {
    >        	},
    >        	//指令所在的模板被重新解析时
    >        	update (element, binding) {
    >        	},
    >        })
    >        ```
         >
         >        通过这样定义的模板就是全局的，可在其他地方使用
  >
  >   5. 其他问题：当要使用必要长的名字进行定义一个名字时，不能使用驼峰命名法，Vue会将字母转换为小写，如果使用的是多个单词的命名，可以使用 ’ - ‘ 在内容之间进行分割，确保内容准确性，对于用 - 进行连接名字，在定义时，使用的是key和value的形式进行创建的对象

- 
