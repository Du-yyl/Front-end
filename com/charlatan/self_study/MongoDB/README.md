MongoDB的安装注意事项和启动
=

- `MongoDB`安装时要手动配置路径，当在控制台输入：

```shell
mongod --version
```

出现配置信息说明安装并配置成功

- MongoDB会在启动目录的根目录下的`data\db`目录下作为数据的默认存储目录  
  也可以通过 ：

```shell
  mongod --dbpath 数据存储路径
```

- 停止服务：
  1. 在开启的控制台直接 ctrl + c 进行停止
  2. 直接将开始的窗口关闭即可


- mongo链接数据库：   
  mongo 回车 ，连接本地的mongo服务
- 退出：   
  在连接的状态下，输入 exit

基本命令
=

```shell
  show dbs                查看数据库列表
  show databases
  use 数据库名称           切换到指定数据库【如果没有会自动新建】
                         （这里的新建不会立即新建，而是当插入第一个数据时才会新建）
  db                      查看当前操作的数据库
  show collection         显示指定数据库中的项目
  db.项目名称.find()        显示指定名称的全部内容
  mongod --dbpath 数据存储路径 --port 四位以上数字  指定端口号 
```

增
-

```sql
db.集合名.insert(doc)        向指定集合中添加一个文档【一次插入一个或多个文档】
  如：要将{name:"Tom",age:20}进行添加到test到stus中
    test.stus.insert({name:"Tom",age:20})

db.集合名.insert(doc)			
db.集合名.insertOne(doc)			向指定的集合中添加一个文档

db.集合名.insert([doc1,doc2])
db.集合名.insertMany([doc1,doc2])	向指定集合中添加多个文档，文档包含在一个数组中
```

> 当执行添加语句时，即使是一摸一样的内容，会通过生成的ID进行区分，这个ID通过自动调用生成，也可以通过
>
>   ```sql
>   ObjectId()
>   ```
>
>   手动调用生成，这个ID通过时间戳和机器码生成，不会重复。在添加数据时可以通过
>
>   `````````````````````sql
>   _id = "指定的ID"
>   `````````````````````
>
>   进行指定，但要确保ID的唯一性

## 查

```aql
db.集合名.find()			find用于查询所有符合条件的sql【find中可以传入一个对象作为参数，空对象和不写，效果相同】
db.集合名.findOne(条件)		找出符合条件的第一个元素
db.集合名.find(条件).count()		不显示具体数据，将数据的总数返回
db.集合名.find(条件).length 		也可以将总数进行返回
```

> 在查询的结果后跟随limit（数目），可以指定返回的结果的数量
>
>   skip可以指定跳过多少条数据， db.集合.find().skip(10).limit(10)    指的是显示10-20条数据
>
>   当skip和limit的顺序写反时， db.集合.find().limit(10).skip(10)    MongoDB会自动调整skip的位置，来保证正确的显示

```sql
$gt							返回大于指定元素的内容，不包含本身
	集合.find({指定字段：{$gt:字段}})
$gte						返回的是大于指定元素的内容，包含本身
eq							等于指定字段
lt							小于指定字段，不包含本身
lte							小于，包含本身
	
	db.集合.find(指定字段:{$gt:200,$lt:500})		指定集合中比200大，比500小，多个条件使用逗号间隔
	
	
	
```

## 改

```sql
db.集合名.update(查询条件，修改的新对象)				将指定的集合进行修改
				【默认情况下update会使用新对象替换旧对象】		
修改的对象的格式：{$set:{要修改成的内容}}				set只会修改一个值，不会进行全部的替换
{unset:{内容}}							用于删除文档的指定内容
updateMany()							同时修改多个符合条件的元素
reqplaceOne()							替换一个问文档
```

## 删

```sql
db.collection.remove()					remove两个参数，第二个参数指定是否删多个，是的话就是删一个，默认全删
db.集合.deleteOne()
db.集合.deleteMany()						删除符合条件的文档

db.集合.drop()							删除集合
数据库.dropDatabase()						删库
```

> 删除和其他元素不同，他是必须传参的，不穿参直接报错，但是当传一个空的参数时，会把所有东西全部删除
>
>   【并且对于要清空集合的需求使用remove性能会更差，直接将集合删除性能更好，因为remove是一个一个对比然后进行删除的，而删集合直接全部干掉】

> ### 业务中的删库
>
>   因为在真正的业务中很少会涉及到数据的删除，即使是用户删除也是如此，用户的删除只是让指定的数据不见，而不是删除，可以定义一个字段isDel来判断这个信息是否是删除的，如果是删除的，那么显示没有，反之正常显示，以此来达到保留数据并返回结果的目的

## 文档之间的关系

> 一对一    (one to one)
>
>   ​ 在文档中嵌套文档，实现一对一，将其中一个作为另一个的属性进行嵌套
>
>   ```sql
>   db.aAndb.insertMany([
>       {
>           name:"a1",
>           a_b:{
>               name:"b1"
>           }
>       }
>   ])
>   ```
>
>   一对多/多对一 (one to many)
>
>    - 可以通过内嵌的方式进行实现，将把属性的嵌套换成数组的嵌套
>
>    - 也可以在指定的集合中保留要关联元素的ID，这样能达到类似效果
       >
       >         ```sql
>         db.c.insertMany([{
>             name:"c1"
>         },{
>             name:"c2"
>         },{
>             name:"c3"
>         }])
>         
>         db.d.insertOne({
>             list:["元素1","元素2"],
>             d_c:"61e81b2b0dd4593ee978eb49"
>         })
>         
>         db.d.insertOne({
>             list:["元素1","元素2"],
>             d_c:"61e81b2b0dd4593ee978eb4a"
>         })
>         ```
       >
       >         ​ 在c中保留着用户的信息，不同的用户的名字对应不同的ID，当要使d中的数据和c中数据进行关联，将c中不同name的ID传到d中，在d中进行保留
>
>   多对多    (many to many)
>
>   ​ 和一对多类似，将一对多中单个的ID转换为多个
